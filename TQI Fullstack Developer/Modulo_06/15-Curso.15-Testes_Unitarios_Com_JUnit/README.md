## Instrutor

- Willyan Guimar√£es Caetano (Senior Software Engineer | Tech Lead | Java | Backend)
- Contato Linkedin: / [willyancaetanodev](https://www.linkedin.com/in/willyancaetanodev/)

## Parte 1 - Apresenta√ß√£o do curso

### üü© V√≠deo 01 - Apresenta√ß√£o do curso

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_01.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/testes-unitarios-com-junit/learning/66d6b610-ab3e-4475-b71b-675462c1ab49?autoplay=1

Este documento resume a introdu√ß√£o ao curso de Testes Unit√°rios com JUnit, apresentado por William, um desenvolvedor Java experiente. O curso visa n√£o apenas ensinar a ferramenta, mas tamb√©m a fundamenta√ß√£o t√©cnica e as motiva√ß√µes por tr√°s da escrita de testes de qualidade.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h01m24s992.jpg" alt="" width="840">
</p>

Nesta introdu√ß√£o, o instrutor Willyan Guimar√£es Caetano apresenta o curso focado em **Testes Unit√°rios com JUnit**. O objetivo central desta jornada √© capacitar o desenvolvedor a utilizar esta ferramenta essencial do ecossistema Java para garantir a qualidade e o funcionamento isolado de componentes de software.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h01m26s629.jpg" alt="" width="840">
</p>

O instrutor compartilha seu perfil profissional e pessoal para estabelecer o contexto de sua experi√™ncia:

* **Experi√™ncia Profissional**: Atua h√° 10 anos com a tecnologia Java, possuindo especialidade e paix√£o pelo desenvolvimento **Backend**, al√©m de interesse em arquitetura e design de c√≥digo.
* **Vida Pessoal**: Seus passatempos incluem jogos, fotografia e viagens.
* **Contato**: Disponibiliza seu perfil no LinkedIn para conex√µes e troca de conhecimentos t√©cnicos.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h01m31s391.jpg" alt="" width="840">
</p>

Os objetivos principais do curso est√£o estruturados em tr√™s pilares fundamentais:

1. **Motiva√ß√£o**: Compreender a fundamenta√ß√£o t√©cnica e as circunst√¢ncias que levam √† necessidade de se escrever testes unit√°rios.
2. **Configura√ß√£o**: Conhecer o JUnit e aprender como configurar a ferramenta adequadamente em projetos Java.
3. **Aprofundamento**: Explorar os recursos avan√ßados que a biblioteca prov√™ para a constru√ß√£o de testes efetivos.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h01m32s818.jpg" alt="" width="840">
</p>

O percurso do aprendizado est√° dividido em etapas incrementais:

* **Aula 1**: Focada na teoria e nos motivos para a ado√ß√£o de testes unit√°rios.
* **Aula 2**: Parte pr√°tica inicial com a cria√ß√£o de um "Hello World" utilizando JUnit.
* **Aula 3**: Detalhamento t√©cnico dos recursos, incluindo as principais anota√ß√µes e funcionalidades da ferramenta para aprimorar os testes.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h01m34s590.jpg" alt="" width="840">
</p>

A fase final do curso aborda a integra√ß√£o e a evolu√ß√£o da pr√°tica de testes:

* **Aula 4**: Explora como as principais IDEs do mercado oferecem suporte e recursos para facilitar a execu√ß√£o e gerenciamento dos testes.
* **Aula 5**: Apresenta√ß√£o de boas pr√°ticas e premissas para a escrita de testes de alta qualidade.
* **Aula 6**: Conclus√£o com insights para o desenvolvimento cont√≠nuo da habilidade de testagem.      


## Parte 2 - Por que escrever testes unit√°rios?

### üü© V√≠deo 02 - Por que escrever testes unit√°rios?

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_02.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/testes-unitarios-com-junit/learning/f1526efd-2e98-4c3d-931e-3e9e889867e8?autoplay=1

Este guia resume a primeira aula do curso de testes unit√°rios, abordando desde a defini√ß√£o fundamental at√© a import√¢ncia estrat√©gica de implementar testes no ciclo de vida de desenvolvimento de software.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h21m16s727.jpg" alt="" width="840">
</p>

Esta √© a aula inaugural do curso voltado para o aprendizado de testes unit√°rios utilizando o framework JUnit. O foco inicial desta sess√£o √© explorar as motiva√ß√µes e a import√¢ncia de se escrever esses testes dentro do fluxo de desenvolvimento.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h21m20s931.jpg" alt="" width="840">
</p>

Os objetivos centrais desta etapa consistem em fornecer uma compreens√£o clara sobre a defini√ß√£o de testes unit√°rios e demonstrar a relev√¢ncia fundamental dessa pr√°tica para a qualidade e estabilidade do software.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h21m23s649.jpg" alt="" width="840">
</p>

Testes unit√°rios, tamb√©m conhecidos como testes de unidade, focam em validar a menor parte funcional de uma aplica√ß√£o. Isso implica testar isoladamente componentes como fun√ß√µes, m√©todos ou classes. Tradicionalmente, esses testes s√£o elaborados simultaneamente ao desenvolvimento do c√≥digo-fonte.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h21m28s739.jpg" alt="" width="840">
</p>

Abaixo, apresenta-se um exemplo pr√°tico de uma regra de neg√≥cio simples e seu respectivo teste unit√°rio utilizando JUnit:

```java
class Pessoa {
    //construtor, atributos e outros m√©todos
    public boolean ehMaiorDeIdade() {
        return idade > 18;
    }
}

class PessoaTeste {
    @Test
    void validaVerificacaoDeMaioridade() {
        Pessoa joaozinho = new Pessoa ("Jo√£o", LocalDate.of (2004, 1, 1));
        Assertions.assertTrue(joaozinho.ehMaiorDeIdade());
    }
}

```

Neste exemplo, a classe de teste verifica se a l√≥gica do m√©todo `ehMaiorDeIdade` retorna o valor esperado ao instanciar um objeto com uma data de nascimento espec√≠fica.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h21m34s821.jpg" alt="" width="840">
</p>

A import√¢ncia dos testes unit√°rios se manifesta em diversas situa√ß√µes cr√≠ticas do cotidiano de um desenvolvedor:

* **Compreens√£o do c√≥digo:** Facilitam o entendimento da l√≥gica interna por novos membros da equipe.
* **Corre√ß√£o de bugs:** Permitem ajustar falhas com a seguran√ßa de que o comportamento esperado ser√° mantido.
* **Refatora√ß√£o segura:** Oferecem suporte para melhorar a estrutura do c√≥digo sem introduzir novos defeitos.
* **Entrega de funcionalidades:** Garantem que novas features cheguem ao usu√°rio final com maior confiabilidade.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h21m42s817.jpg" alt="" width="840">
</p>

Al√©m dos benef√≠cios diretos no c√≥digo, os testes unit√°rios fundamentam conceitos avan√ßados de engenharia de software:

* **Pir√¢mide de Testes:** Representam a base s√≥lida e volumosa de uma estrat√©gia de testes eficiente.
* **M√©tricas de Qualidade:** Servem como indicadores de confiabilidade e cobertura do sistema.
* **Automa√ß√£o e Agilidade:** S√£o essenciais para processos de execu√ß√£o automatizada e para a manuten√ß√£o de uma cultura √°gil de desenvolvimento.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h21m47s809.jpg" alt="" width="840">
</p>

Para aprofundamento nos temas de cultura de qualidade e pr√°ticas de DevSecOps, s√£o sugeridas as seguintes refer√™ncias externas:

* Artigos sobre a import√¢ncia dos testes unit√°rios no iMasters.
* Guias pr√°ticos sobre defini√ß√£o e implementa√ß√£o de testes no Medium.
* Estudos sobre a promo√ß√£o de qualidade no desenvolvimento de software √°gil.      

#### Refer√™ncias

- https://imasters.com.br/devsecops/testes-unitarios-qual-a-importancia  
- https://dayvsonlima.medium.com/entenda-de-uma-vez-por-todas-o-que-s%C3%A3o-testes-unit%C3%A1rios-para-que-servem-e-como-faz%C3%AA-los-2a6f645bab3  
- https://medium.com/cesar-update/aprendendo-a-promover-uma-cultura-de-qualidade-no-desenvolvimento-de-software-%C3%A1gil-f5a3444dd


## Parte 3 - Hello world, JUnit!

### üü© V√≠deo 03 - Hello World no JUNIT

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_03.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/testes-unitarios-com-junit/learning/311d5f09-9441-4802-8bca-c48e767a74b1?autoplay=1

Esta aula marca o in√≠cio pr√°tico no mundo dos testes unit√°rios com Java, cobrindo desde a base hist√≥rica e arquitetural do JUnit at√© a configura√ß√£o de projetos reais utilizando Maven e Gradle.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h39m27s459.jpg" alt="" width="840">
</p>

Nesta aula introdut√≥ria de pr√°tica, o foco √© a cria√ß√£o do primeiro teste unit√°rio utilizando o **JUnit**. O framework √© uma ferramenta *open source* fundamental para o ecossistema Java, tendo sido criado por figuras ic√¥nicas da engenharia de software: **Erich Gamma** (coautor do livro *Design Patterns* e membro do *Gang of Four*) e **Kent Beck** (pioneiro do *Extreme Programming* e do TDD). A proposta √© integrar a pr√°tica de testes massivos ao ciclo de desenvolvimento √°gil.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h39m29s579.jpg" alt="" width="840">
</p>

Embora o JUnit 4 ainda seja encontrado em muitos projetos legados, o mercado converge para o **JUnit 5**, que √© o foco deste estudo. A arquitetura da vers√£o 5 √© modular e se divide em tr√™s pilares principais:

* **JUnit Platform**: O motor respons√°vel por lan√ßar e executar os testes na JVM.
* **JUnit Jupiter**: Cont√©m o novo modelo de programa√ß√£o e extens√£o para a escrita de testes no JUnit 5 (inclui as anota√ß√µes e classes principais).
* **JUnit Vintage**: Um motor de teste que permite a execu√ß√£o de testes escritos nas vers√µes 3 e 4, garantindo a retrocompatibilidade.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h39m30s941.jpg" alt="" width="840">
</p>

Para configurar o JUnit em um projeto, o primeiro passo √© localizar a depend√™ncia correta em reposit√≥rios p√∫blicos, como o **Maven Repository**. A depend√™ncia recomendada para iniciar projetos modernos √© o `junit-jupiter-engine`, que traz as implementa√ß√µes necess√°rias do motor Jupiter para rodar os testes.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h39m33s832.jpg" alt="" width="840">
</p>

A imagem refor√ßa a distin√ß√£o entre os m√≥dulos. Enquanto o **Jupiter** √© onde escrevemos nosso c√≥digo de teste moderno, o **Platform** atua como a infraestrutura de execu√ß√£o e o **Vintage** serve como uma "ponte" para que c√≥digos antigos n√£o quebrem ao serem migrados para o ambiente do JUnit 5.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h39m39s027.jpg" alt="" width="840">
</p>

No gerenciador de depend√™ncias **Gradle**, a configura√ß√£o √© feita no arquivo `build.gradle`. Deve-se adicionar a biblioteca do motor Jupiter dentro do bloco de depend√™ncias para que o projeto reconhe√ßa as classes do JUnit.

```groovy
dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.8.2'
}

```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h39m43s556.jpg" alt="" width="840">
</p>

Um detalhe crucial na configura√ß√£o do Gradle √© informar explicitamente que o projeto deve utilizar a plataforma JUnit para a execu√ß√£o das tarefas de teste. Sem a instru√ß√£o `useJUnitPlatform()`, o Gradle pode n√£o identificar ou executar os testes corretamente.

```groovy
test {
    useJUnitPlatform()
}

```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h39m48s749.jpg" alt="" width="840">
</p>

Para exemplificar o uso, temos uma classe simples chamada `Pessoa`. Ela possui atributos b√°sicos como nome e data de nascimento, al√©m de um m√©todo que calcula a idade baseando-se na data atual.

```java
public class Pessoa {
    private String nome;
    private LocalDateTime nascimento;

    public Pessoa(String nome, LocalDateTime nascimento) {
        this.nome = nome;
        this.nascimento = nascimento;
    }

    public int getIdade() {
        return (int) ChronoUnit.YEARS.between(nascimento, LocalDateTime.now());
    }
}

```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h40m01s023.jpg" alt="" width="840">
</p>

Ao criar a classe de teste `PessoaTest`, utilizamos a anota√ß√£o `@Test` para marcar o m√©todo que validar√° o comportamento. Neste cen√°rio, instanciamos uma pessoa chamada "J√∫lia" com data de nascimento em 01/01/2020.

```java
class PessoaTest {

    @Test
    void validarCalculoDeIdade() {
        Pessoa pessoa = new Pessoa("J√∫lia", LocalDateTime.of(2020, 1, 1, 15, 0, 0));
    }
}

```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h40m12s986.jpg" alt="" width="840">
</p>

O cora√ß√£o do teste √© a asser√ß√£o. Utilizamos a classe `Assertions.assertEquals` para comparar o valor esperado (neste caso, 2 anos) com o resultado retornado pelo m√©todo `getIdade()`.

```java
@Test
void validarCalculoDeIdade() {
    Pessoa pessoa = new Pessoa("J√∫lia", LocalDateTime.of(2020, 1, 1, 15, 0, 0));
    Assertions.assertEquals(2, pessoa.getIdade());
}

```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h40m28s185.jpg" alt="" width="840">
</p>

Ap√≥s a execu√ß√£o no ambiente IntelliJ utilizando Gradle, o painel de testes indica sucesso. O √≠cone verde ao lado do nome do m√©todo `validarCalculoDeIdade` confirma que o valor calculado pelo sistema condiz com o valor esperado pela asser√ß√£o.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h40m54s620.jpg" alt="" width="840">
</p>

Para projetos que utilizam o **Maven**, a configura√ß√£o ocorre no arquivo `pom.xml`. Adicionamos o artefato `junit-jupiter-engine` dentro da se√ß√£o `<dependencies>`. O Maven gerencia o download autom√°tico das bibliotecas necess√°rias.

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <version>5.8.2</version>
    <scope>test</scope>
</dependency>

```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h41m03s067.jpg" alt="" width="840">
</p>

Mesmo em um projeto Maven, a estrutura do teste permanece id√™ntica. A IDE integra-se ao gerenciador de depend√™ncias para compilar e rodar os testes da mesma forma, garantindo que a l√≥gica de neg√≥cio (como a classe `Conta` ou `Pessoa`) esteja protegida por verifica√ß√µes automatizadas.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h41m08s376.jpg" alt="" width="840">
</p>

Durante o processo de execu√ß√£o no Maven, √© poss√≠vel observar no console o download das depend√™ncias transitivas e a inicializa√ß√£o do motor de testes. O Maven coordena o ciclo de vida do projeto, garantindo que os testes sejam executados antes de qualquer empacotamento.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h41m11s723.jpg" alt="" width="840">
</p>

A imagem demonstra o resultado final de uma bateria de testes sendo conclu√≠da. A interface da IDE agrupa os testes por classe e m√©todo, facilitando a identifica√ß√£o visual de qualquer falha.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h41m19s970.jpg" alt="" width="840">
</p>

A estrutura de diret√≥rios segue o padr√£o convencional da ind√∫stria: classes de produ√ß√£o ficam em `src/main/java`, enquanto as classes de teste, como `PessoaTest`, residem obrigatoriamente em `src/test/java`. Isso separa o c√≥digo que vai para o cliente final do c√≥digo utilizado apenas durante o desenvolvimento e garantia de qualidade.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-17-14h41m29s068.jpg" alt="" width="840">
</p>

Para aprofundamento, os recursos oficiais s√£o fundamentais. O reposit√≥rio oficial no GitHub e o guia do usu√°rio do JUnit 5 oferecem detalhes t√©cnicos avan√ßados, exemplos de extens√µes e melhores pr√°ticas para a escrita de testes robustos.

#### Refer√™ncias

- https://junit.org/junit5/
- https://github.com/junit-team/junit5/
- https://www.baeldung.com/junit-5-gradle
- https://github.com/junit-team/junit5/
- https://www.baeldung.com/junit-5-gradle
- https://maven.apache.org/surefire/maven-surefire-plugin/examples/junit-platform.html


## Parte 4 - Aprofundando nos recursos

### üü© V√≠deo 04 - O b√°sico para testar

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_04.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/testes-unitarios-com-junit/learning/38ef08ba-4873-48a8-8ed6-16db79698496?autoplay=1

Esta aula foca no aprofundamento dos recursos do JUnit, demonstrando na pr√°tica como estruturar testes para uma aplica√ß√£o Java Maven e como utilizar as principais asser√ß√µes para validar o comportamento do c√≥digo.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-13h34m12s253.jpg" alt="" width="840">
</p>

Nesta etapa inicial da aula, o foco √© estabelecer os objetivos principais, que consistem em explorar detalhadamente os recursos fornecidos pelo framework JUnit. A proposta √© capacitar o desenvolvedor a utilizar essas ferramentas de forma eficiente no cotidiano profissional para garantir a qualidade do c√≥digo.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-13h34m20s330.jpg" alt="" width="840">
</p>

Para ilustrar os testes na pr√°tica, utiliza-se um projeto Java estruturado com Maven, contendo a classe de dom√≠nio `Pessoa`. Esta classe possui atributos para nome e data de nascimento, al√©m de m√©todos que calculam a idade baseada na data atual e verificam a maioridade do indiv√≠duo.

```java
public class Pessoa {
    private String nome;
    private LocalDateTime nascimento;

    public Pessoa(String nome, LocalDateTime nascimento) {
        this.nome = nome;
        this.nascimento = nascimento;
    }

    public int getIdade() {
        return (int) ChronoUnit.YEARS.between(nascimento, LocalDateTime.now());
    }

    public boolean ehMaiorDeIdade() {
        return getIdade() >= 18;
    }
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-13h34m43s157.jpg" alt="" width="840">
</p>

A estrutura de testes exige uma separa√ß√£o rigorosa de pastas: o c√≥digo de produ√ß√£o fica em `src/main/java`, enquanto os testes devem residir em `src/test/java`. O exemplo abaixo demonstra o uso da anota√ß√£o `@Test` e do m√©todo `Assertions.assertEquals` para validar se o c√°lculo da idade da classe `Pessoa` est√° retornando o valor esperado.

```java
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import java.time.LocalDateTime;

public class PessoaTeste {

    @Test
    void deveCalcularIdadeCorretamente() {
        Pessoa jessica = new Pessoa("J√©ssica", LocalDateTime.of(2000, 1, 1, 15, 0));
        Assertions.assertEquals(22, jessica.getIdade());
    }
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-13h34m55s181.jpg" alt="" width="840">
</p>

Al√©m de validar igualdades, o JUnit permite testar condi√ß√µes booleanas atrav√©s de m√©todos como `assertTrue` e `assertFalse`. √â poss√≠vel incluir m√∫ltiplas valida√ß√µes dentro de um mesmo m√©todo de teste para cobrir diferentes cen√°rios de um comportamento, como testar tanto um caso positivo quanto um negativo de maioridade.

```java
@Test
void deveRetornarSeEhMaiorDeIdade() {
    Pessoa jessica = new Pessoa("J√©ssica", LocalDateTime.of(2000, 1, 1, 15, 0));
    Assertions.assertTrue(jessica.ehMaiorDeIdade());

    Pessoa joao = new Pessoa("Jo√£o", LocalDateTime.now());
    Assertions.assertFalse(joao.ehMaiorDeIdade());
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-13h34m57s868.jpg" alt="" width="840">
</p>

A execu√ß√£o dos testes √© monitorada diretamente pela IDE, que fornece um feedback visual sobre o sucesso ou falha das opera√ß√µes. Neste caso, o JUnit 5 gerenciou a execu√ß√£o do teste `deveRetornarSeEhMaiorDeIdade`, confirmando que as condi√ß√µes de maioridade foram validadas corretamente conforme o planejado.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-13h35m01s359.jpg" alt="" width="840">
</p>

A estrutura b√°sica de um teste unit√°rio bem definido compreende o uso da anota√ß√£o `@Test`, a constru√ß√£o de um cen√°rio (prepara√ß√£o dos dados) e a execu√ß√£o das asser√ß√µes. Por padr√£o, os m√©todos de teste n√£o devem retornar valores, utilizando sempre o tipo `void`.

```java
class PessoaTeste {
    @Test //--> Anota√ß√£o √© primordial para testar
    void validaVerificacaoDeMaioridade() {
        // cria um cen√°rio
        Pessoa joaozinho = new Pessoa("Jo√£o", LocalDate.of(2004, 1, 1)); 
        // Executa as valida√ß√µes
        Assertions.assertTrue(joaozinho.ehMaiorDeIdade()); 
    }
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-13h35m03s499.jpg" alt="" width="840">
</p>

Para aprofundar os conhecimentos em testes unit√°rios, recomenda-se a consulta √† documenta√ß√£o oficial da classe `Assertions` no site do JUnit. Recursos adicionais, como tutoriais pr√°ticos sobre o uso de asser√ß√µes, s√£o fundamentais para entender as diversas possibilidades de valida√ß√£o de dados.      

#### Refer√™ncias

- https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html  
- https://www.tutorialspoint.com/junit/junit_using_assertion.htm


### üü© V√≠deo 05 - Mais algumas asser√ß√µes

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_05.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/testes-unitarios-com-junit/learning/67185e7a-6484-4e73-9caf-2cb6690b1b3b?autoplay=1

Este guia explora o uso da classe Assertions do JUnit, demonstrando como validar diferentes cen√°rios de dados, desde arrays complexos at√© a nulidade de objetos, al√©m de dicas para manter o c√≥digo de teste limpo e eficiente.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-14h41m40s856.jpg" alt="" width="840">
</p>

Nesta etapa, daremos continuidade ao estudo de testes unit√°rios com JUnit, focando na explora√ß√£o pr√°tica da classe **Assertions**. O objetivo √© analisar cen√°rios reais, como a compara√ß√£o de arrays e a valida√ß√£o de refer√™ncias nulas, para compreender como a API nos ajuda a assegurar o comportamento esperado do c√≥digo.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-14h41m51s049.jpg" alt="" width="840">
</p>

Um dos recursos da classe `Assertions` √© o m√©todo `assertArrayEquals`, utilizado para comparar se dois arrays s√£o id√™nticos. √â importante notar que a ordem dos par√¢metros importa: primeiro passamos o valor esperado e depois o valor atual. No exemplo abaixo, o teste resultar√° em erro caso os arrays possuam tamanhos diferentes ou conte√∫dos distintos em seus respectivos √≠ndices.

```java
@Test
void validarLancamentos() {
    int[] primeiroLancamento = {10, 20, 30, 40, 50};
    int[] segundoLancamento = {-1, 5, 2, 3, 10, 16, 17};

    Assertions.assertArrayEquals(primeiroLancamento, segundoLancamento);
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-14h42m14s474.jpg" alt="" width="840">
</p>

Para lidar com refer√™ncias de objetos, o JUnit oferece os m√©todos `assertNull` e `assertNotNull`. Eles s√£o essenciais para garantir que um objeto foi (ou n√£o) instanciado corretamente ap√≥s a execu√ß√£o de uma l√≥gica de neg√≥cio. No exemplo, validamos inicialmente que a vari√°vel `pessoa` √© nula e, ap√≥s a instancia√ß√£o, garantimos que ela cont√©m uma refer√™ncia v√°lida.

```java
@Test
void validarSeObjetoEstaNulo() {
    Pessoa pessoa = null;
    Assertions.assertNull(pessoa);

    pessoa = new Pessoa("Luciano", LocalDateTime.now());
    Assertions.assertNotNull(pessoa);
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-14h42m23s252.jpg" alt="" width="840">
</p>

Abaixo, vemos o ajuste dos arrays para que o teste de lan√ßamentos seja bem-sucedido, igualando seus conte√∫dos. Al√©m disso, a API do JUnit √© vers√°til ao lidar com diferentes tipos num√©ricos atrav√©s de sobrecargas do m√©todo `assertEquals`. Isso permite comparar valores de tipos como `int`, `double`, `float` e outros, garantindo que a precis√£o e a igualdade sejam mantidas conforme a documenta√ß√£o da IDE sugere.

```java
@Test
void validarLancamentos() {
    int[] primeiroLancamento = {10, 20, 30, 40, 50};
    int[] segundoLancamento = {10, 20, 30, 40, 50};

    Assertions.assertArrayEquals(primeiroLancamento, segundoLancamento);
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-14h42m25s388.jpg" alt="" width="840">
</p>

Uma pr√°tica comum no desenvolvimento de testes para tornar o c√≥digo mais limpo e leg√≠vel √© a utiliza√ß√£o de **importa√ß√µes est√°ticas**. Ao importar os m√©todos da classe `Assertions` de forma est√°tica, eliminamos a necessidade de repetir o prefixo `Assertions.` antes de cada chamada, deixando as asser√ß√µes mais diretas.

```java
import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertNotNull;
// Ou utilizando o curinga para todos os m√©todos
import static org.junit.jupiter.api.Assertions.*;
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-14h42m31s313.jpg" alt="" width="840">
</p>

Para aprofundar os conhecimentos sobre as asser√ß√µes dispon√≠veis no JUnit 5, recomenda-se a consulta √† documenta√ß√£o oficial da API e a guias de refer√™ncia r√°pida. Compreender a variedade de m√©todos dispon√≠veis na classe `Assertions` √© fundamental para realizar valida√ß√µes precisas e garantir a integridade dos testes unit√°rios.      

#### Refer√™ncias

- https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html  
- https://www.tutorialspoint.com/junit/junit_using_assertion.htm


### üü© V√≠deo 06 - After e Before

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_06.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/testes-unitarios-com-junit/learning/dc153cc9-20a0-4907-8cc4-10b6c8f4c4b9?autoplay=1

Este guia resume a terceira etapa da aula sobre testes unit√°rios com JUnit, focando em como gerenciar o estado dos testes e recursos do sistema (como conex√µes de banco de dados) utilizando as anota√ß√µes de configura√ß√£o e limpeza.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-15h17m29s273.jpg" alt="" width="840">
</p>

Nesta terceira etapa da aula de testes unit√°rios com JUnit, o foco √© o aprofundamento nos recursos de **After e Before**. Estas anota√ß√µes s√£o fundamentais para gerenciar o ciclo de vida dos testes, permitindo a configura√ß√£o e a limpeza de ambientes de forma automatizada e organizada.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-15h17m45s704.jpg" alt="" width="840">
</p>

Para exemplificar o uso dessas ferramentas, √© criada uma classe hipot√©tica chamada `BancoDeDados`. Esta classe simula um gerenciador de conex√µes, contendo m√©todos est√°ticos para iniciar e finalizar a comunica√ß√£o com o banco de dados. Para rastrear essas opera√ß√µes, utiliza-se a classe `Logger`, que registra no console o momento em que a conex√£o √© estabelecida ou encerrada.

```java
package one.digitalinnovation.junit;

import java.util.logging.Logger;

public class BancoDeDados {

    private static final Logger LOGGER = Logger.getLogger(BancoDeDados.class.getName());

    public static void iniciarConexao() {
        //fez algo
        LOGGER.info("Iniciou conexao");
    }

    public static void finalizarConexao() {
        //fez algo
        LOGGER.info("finalizou conexao");
    }
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-15h17m57s539.jpg" alt="" width="840">
</p>

```java
package one.digitalinnovation.junit;

import org.junit.jupiter.api.*;

public class ConsultarDadosDePessoaTest {

    @BeforeAll
    static void configuraConexao() {
        BancoDeDados.iniciarConexao();
        System.out.println("rodou configuraConexao");
    }

    @Test
    void validarDadosDeRetorno() {
        Assertions.assertTrue(true);
    }

    @AfterAll
    static void finalizarConexao() {
        BancoDeDados.finalizarConexao();
        System.out.println("rodou finalizarConexao");
    }
}
```

### üü© V√≠deo 07 - Assumptions e Testes condicionais

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_07.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/testes-unitarios-com-junit/learning/212ae840-ea88-4ab8-a6ee-ca1ed26c1342?autoplay=1

Este guia aborda como controlar a execu√ß√£o de testes unit√°rios baseando-se em condi√ß√µes espec√≠ficas do ambiente, como vari√°veis de sistema, sistema operacional e vers√£o do Java, utilizando os recursos de Assumptions (Suposi√ß√µes) e Testes Condicionais do JUnit 5.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-16h10m59s244.jpg" alt="" width="840">
</p>

Nesta etapa da aula, introduzimos os conceitos de **Assumptions** (suposi√ß√µes) e **testes condicionais** no JUnit. O termo *assumption* refere-se a uma hip√≥tese ou presun√ß√£o que deve ser satisfeita para que um teste seja executado. Diferente das asser√ß√µes comuns, se uma condi√ß√£o presumida n√£o for atendida, o teste n√£o falha, mas √© interrompido ou ignorado, permitindo que o c√≥digo valide se o ambiente ou contexto √© adequado para aquela execu√ß√£o espec√≠fica.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-16h11m10s074.jpg" alt="" width="840">
</p>

Para implementar essas valida√ß√µes programaticamente, utilizamos a classe `Assumptions`. No exemplo pr√°tico, o m√©todo `assumeFalse` √© utilizado para verificar se o usu√°rio logado no sistema operacional n√£o √© o "root". Caso a condi√ß√£o seja verdadeira (ou seja, o usu√°rio logado seja "root"), o restante do teste, incluindo a `Assertions.assertEquals`, n√£o ser√° processado.

```java
@Test
void validarAlgoSomenteNoUsuarioWillyan() {
    Assumptions.assumeFalse("root".equals(System.getenv("USER")));
    Assertions.assertEquals(10, 5 + 5);
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-16h11m18s497.jpg" alt="" width="840">
</p>

O JUnit 5 oferece uma forma mais declarativa de lidar com condi√ß√µes atrav√©s de anota√ß√µes. A anota√ß√£o `@EnabledIfEnvironmentVariable` permite especificar que um teste s√≥ deve ser habilitado se uma vari√°vel de ambiente espec√≠fica (neste caso, `USER`) corresponder a um valor determinado (`willyan`). Isso elimina a necessidade de l√≥gica condicional manual dentro do corpo do m√©todo do teste.

```java
@Test
@EnabledIfEnvironmentVariable(named = "USER", matches = "willyan")
void validarAlgoSomenteNoUsuarioWillyan() {
    Assertions.assertEquals(10, 5 + 5);
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-16h11m26s680.jpg" alt="" width="840">
</p>

Al√©m de vari√°veis de ambiente, √© poss√≠vel condicionar a execu√ß√£o baseando-se no **Sistema Operacional (OS)**. Atrav√©s da anota√ß√£o `@EnabledOnOs`, podemos restringir o teste para rodar apenas em plataformas espec√≠ficas, como o MacOS. Se o teste for executado em um ambiente Linux, como demonstrado no console da imagem, o JUnit identifica a incompatibilidade e pula a execu√ß√£o do teste.

```java
@Test
@EnabledOnOs(OS.MAC)
void validarAlgoSomenteNoUsuarioWillyan() {
    Assertions.assertEquals(10, 5 + 5);
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-16h11m37s339.jpg" alt="" width="840">
</p>

Outra funcionalidade poderosa √© o filtro por vers√£o do **JRE (Java Runtime Environment)**. Utilizando `@EnabledOnJre`, o desenvolvedor pode garantir que o teste execute apenas em vers√µes espec√≠ficas do Java (como o Java 8 ou Java 17). No exemplo visual, o teste foi ignorado porque o ambiente de execu√ß√£o atual estava utilizando o JRE 17.0.1, enquanto o teste estava configurado para habilitar-se apenas no `JAVA_8`.

```java
@Test
@EnabledOnJre(JAVA_8)
void validarAlgoSomenteNoUsuarioWillyan() {
    Assertions.assertEquals(10, 5 + 5);
}
```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-16h11m42s100.jpg" alt="" width="840">
</p>

Para aprofundamento nos temas de assumptions e execu√ß√µes condicionais, as refer√™ncias oficiais do JUnit 5 e guias da comunidade como Baeldung e Mkyong s√£o recursos fundamentais. Estes materiais detalham casos mais complexos, como o uso de intervalos de vers√µes de JRE e combina√ß√µes de m√∫ltiplas condi√ß√µes de execu√ß√£o.

#### Refer√™ncias

- https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assumptions.html  
- https://www.baeldung.com/junit-5#2-assumptions  
- https://mkyong.com/junit5/junit-5-assumptions-examples/  
- https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution

### üü© V√≠deo 08 - Testando exceptions

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_08.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/testes-unitarios-com-junit/learning/da5e03c2-caef-446e-a73c-ed274e47e6fd?autoplay=1

Este documento resume a quinta etapa da terceira aula do curso de Testes Unit√°rios, focada em como validar comportamentos inesperados ou erros de l√≥gica de neg√≥cio atrav√©s do tratamento de exce√ß√µes.

### Anota√ß√µes

#### Testando Exce√ß√µes com JUnit 5

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-16h49m23s340.jpg" alt="" width="840">
</p>

Nesta etapa, o foco √© o aprofundamento nos testes de cen√°rios excepcionais. O objetivo √© validar o comportamento do sistema quando uma opera√ß√£o n√£o segue o fluxo feliz e resulta no lan√ßamento de uma exce√ß√£o. Para exemplificar essa necessidade, considera-se uma opera√ß√£o de transfer√™ncia banc√°ria onde certas condi√ß√µes ‚Äî como o valor da transfer√™ncia ‚Äî devem ser validadas obrigatoriamente antes da execu√ß√£o da l√≥gica de neg√≥cio.

#### Valida√ß√£o de Cen√°rios de Erro com `assertThrows`

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-16h50m03s018.jpg" alt="" width="840">
</p>

Para testar se uma exce√ß√£o √© lan√ßada corretamente, utiliza-se o m√©todo `Assertions.assertThrows`. No exemplo pr√°tico, √© criada uma classe de teste `ExceptionsTeste` para validar a l√≥gica da classe `TransferenciaEntreContas`. O teste verifica se, ao tentar transferir um valor inv√°lido (menor ou igual a zero), o sistema lan√ßa uma `IllegalArgumentException`.

```java
@Test
void validarCenarioDeExcecaoNaTransferencia() {
    Conta contaOrigem = new Conta("123456", 0);
    Conta contaDestino = new Conta("456548", 100);

    TransferenciaEntreContas transferenciaEntreContas = new TransferenciaEntreContas();

    Assertions.assertThrows(IllegalArgumentException.class, () ->
            transferenciaEntreContas.transfere(contaOrigem, contaDestino, -1));
}
```

#### Garantindo a Aus√™ncia de Exce√ß√µes com `assertDoesNotThrow`

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-16h50m14s522.jpg" alt="" width="840">
</p>

Uma varia√ß√£o importante √© o m√©todo `Assertions.assertDoesNotThrow`, utilizado para garantir que um bloco de c√≥digo seja executado sem lan√ßar nenhuma exce√ß√£o. No exemplo visualizado, ao alterar o valor da transfer√™ncia para um n√∫mero positivo (como 20), o teste espera que a execu√ß√£o ocorra com sucesso. Caso uma exce√ß√£o seja lan√ßada inesperadamente nesse cen√°rio, o JUnit falhar√° o teste, indicando que o comportamento observado divergiu do esperado.

```java
@Test
void validarCenarioDeExcecaoNaTransferencia() {
    Conta contaOrigem = new Conta("123456", 0);
    Conta contaDestino = new Conta("456548", 100);

    TransferenciaEntreContas transferenciaEntreContas = new TransferenciaEntreContas();

    Assertions.assertDoesNotThrow(() -> 
            transferenciaEntreContas.transfere(contaOrigem, contaDestino, 20));
}
```      

### üü© V√≠deo 09 - Ordenando testes

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_09.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/testes-unitarios-com-junit/learning/d42c3721-ace3-4561-931f-5af4ee59be31?autoplay=1

Este guia resume as principais t√©cnicas e anota√ß√µes para controlar a ordem de execu√ß√£o dos testes unit√°rios no JUnit, conforme apresentado na aula. Embora o ideal seja que testes unit√°rios sejam independentes, existem cen√°rios espec√≠ficos onde a ordena√ß√£o √© necess√°ria ou √∫til para a organiza√ß√£o do fluxo de desenvolvimento.

### Anota√ß√µes

#### Ordena√ß√£o de Testes no JUnit 5

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-17h03m36s770.jpg" alt="" width="840">
</p>

Nesta etapa, o foco √© o controle sobre a ordem de execu√ß√£o dos testes unit√°rios. Por padr√£o, o JUnit n√£o garante uma ordem espec√≠fica, o que pode ser problem√°tico em cen√°rios onde a visualiza√ß√£o l√≥gica ou a organiza√ß√£o dos testes facilitam a depura√ß√£o. Para demonstrar essas funcionalidades, foi estruturada uma classe de teste b√°sica com quatro m√©todos representativos: `validaFluxoA`, `validaFluxoB`, `validaFluxoC` e `validaFluxoD`.

---

#### Execu√ß√£o Aleat√≥ria com MethodOrderer.Random

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-17h03m47s151.jpg" alt="" width="840">
</p>

Uma das formas de configurar a ordena√ß√£o √© atrav√©s da anota√ß√£o `@TestMethodOrder`. No exemplo visualizado, utiliza-se o `MethodOrderer.Random.class`, que instrui o JUnit a executar os m√©todos de teste em uma ordem pseudo-aleat√≥ria a cada nova execu√ß√£o. Esta abordagem √© √∫til para garantir que os testes sejam independentes entre si, evitando que o sucesso de um teste dependa do estado deixado por um teste anterior.

```java
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.Assertions;

@TestMethodOrder(MethodOrderer.Random.class)
public class EscolhendoAOrdemTeste {

    @Test
    void validaFluxoA() {
        Assertions.assertTrue(true);
    }

    @Test
    void validaFluxoB() {
        Assertions.assertTrue(true);
    }
}
```

---

#### Ordena√ß√£o por DisplayName

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-02-18-17h04m01s056.jpg" alt="" width="840">
</p>

Outra possibilidade √© ordenar os testes com base no nome de exibi√ß√£o definido pela anota√ß√£o `@DisplayName`. Ao configurar a classe com `@TestMethodOrder(MethodOrderer.DisplayName.class)`, o JUnit seguir√° a ordem alfab√©tica dos textos fornecidos dentro das anota√ß√µes `@DisplayName`. Este recurso √© amplamente utilizado para melhorar a legibilidade dos relat√≥rios de teste, permitindo descri√ß√µes em linguagem natural (como "Teste que valida se o usu√°rio foi criado") enquanto mant√©m a organiza√ß√£o desejada no painel de resultados.

```java
package one.digitalinnovation.junit;

import org.junit.jupiter.api.*;

@TestMethodOrder(MethodOrderer.DisplayName.class)
public class EscolhendoAOrdemTeste {

    @DisplayName("Teste que valida se o usu√°rio foi criado")
    @Test
    void validaFluxoA() {
        Assertions.assertTrue(true);
    }

    @DisplayName("B")
    @Test
    void validaFluxoB() {
        Assertions.assertTrue(true);
    }
}
```      



## Parte 5 - Recursos de testes nas IDEs

### üü© V√≠deo 10 - Visual Studio Code

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_10.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/testes-unitarios-com-junit/learning/c3f5e0e8-f3eb-4277-bea0-eb1d7fceff3e?autoplay=1

### üü© V√≠deo 11 - Eclipse

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_11.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo:

### üü© V√≠deo 12 - IntelliJ IDEA

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_12.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo:

## Parte 6 - Boas pr√°ticas

### üü© V√≠deo 13 - Boas pr√°ticas

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_13.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo:

## Parte 7 - Conclus√£o do curso

### üü© V√≠deo 14 - Conclus√£o do curso

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.15-video_14.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo:

##  Materiais de Apoio

# Certificado: 

- Link na plataforma: 
- Certificado em pdf: