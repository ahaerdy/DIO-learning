## Instrutor

- Camila Cavalcante (Software Developer @ Reclame AQUI | Full Stack | Java | Kotlin | Go | TypeScript | PHP)
- Contato Linkedin: / [cami-la](https://www.linkedin.com/in/cami-la/)
- Reposit√≥rio dos exerc√≠cios usados neste curso: https://github.com/ahaerdy/fork-DIO-curso-dio-intro-collections 

## Parte 1 - Introdu√ß√£o do Curso

### üü© V√≠deo 01 - Apresenta√ß√£o do Curso

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_01.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/a34f3db6-de2b-44fa-a059-6ae7785695cc?autoplay=1

Este v√≠deo serve como uma introdu√ß√£o a um curso sobre o Collections Framework em Java, ministrado por Camila Cavalcante. O curso tem como objetivo capacitar os alunos a entender e aplicar as principais interfaces de Collections (List, Set, Map) e a Stream API, auxiliando na manipula√ß√£o de cole√ß√µes. A instrutora tamb√©m compartilha um breve hist√≥rico pessoal sobre sua jornada na programa√ß√£o, destacando sua paix√£o por desafios e aprendizado cont√≠nuo.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-13h13m39s995.jpg" alt="" width="840">
</p>

Bem-vindos ao curso introdut√≥rio sobre **Collections**. Esta jornada de aprendizado √© guiada por Camila Cavalcante, graduanda em Ci√™ncia da Computa√ß√£o, e tem como foco explorar as estruturas de dados fundamentais para o desenvolvimento Java moderno.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-13h13m41s633.jpg" alt="" width="840">
</p>

### Objetivo do curso

O foco principal √© capacitar o desenvolvedor a compreender o **Collections Framework**. Ao final das aulas, voc√™ ser√° capaz de entender a aplicabilidade das principais interfaces do ecossistema:

* **List**: Para cole√ß√µes que permitem itera√ß√µes ordenadas.
* **Set**: Para cole√ß√µes que focam na singularidade dos elementos.
* **Map**: Para cole√ß√µes estruturadas em pares.

Al√©m disso, o curso abordar√° a **Stream API** e como ela auxilia na manipula√ß√£o dessas cole√ß√µes.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-13h13m43s694.jpg" alt="" width="840">
</p>

### Percurso

O conte√∫do est√° organizado em uma trilha l√≥gica para facilitar o aprendizado progressivo:

* **Aula 1**: Cole√ß√µes com itera√ß√µes ordenadas: List.
* **Aula 2**: Cole√ß√µes com Singularidade: Set.
* **Aula 3**: Cole√ß√µes de Pares: Map.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-13h13m51s134.jpg" alt="" width="840">
</p>

### Mais sobre mim

Camila Cavalcante compartilha detalhes sobre sua trajet√≥ria e interesses na √°rea tecnol√≥gica:

* **Forma√ß√£o**: Estudante de Ci√™ncia da Computa√ß√£o.
* **In√≠cio**: Conheceu a programa√ß√£o atrav√©s do Excel.
* **Tecnologias**: Atua com os frameworks Spring e Angular.
* **Perfil**: Gosta de enfrentar desafios e aprender coisas novas.
* **Projetos**: Aspirante a YouTuber.

Para conectar-se ou explorar seus projetos, voc√™ pode acessar seu **LinkedIn** ou seu perfil no **GitHub**.


### üü© V√≠deo 02 - Vis√£o geral: Collections Framework

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_02.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/10d0027e-1655-464b-b968-748a7fe654a5?autoplay=1

Esta aula introduz o Java Collections Framework, explorando sua import√¢ncia na manipula√ß√£o eficiente de conjuntos de dados. O conte√∫do aborda desde a defini√ß√£o fundamental de uma Collection como um objeto que agrupa m√∫ltiplos elementos, at√© a evolu√ß√£o hist√≥rica da linguagem Java (p√≥s JDK 1.2) que permitiu superar as limita√ß√µes t√©cnicas dos arrays convencionais. A estrutura do framework √© detalhada atrav√©s de seus pilares: interfaces, implementa√ß√µes e algoritmos, preparando o estudante para a aplica√ß√£o pr√°tica em desenvolvimento de software.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h22m50s501.jpg" alt="" width="840">
</p>

Esta √© a tela de abertura da segunda parte do curso introdut√≥rio sobre **Collections**. A aula √© apresentada por Camila Cavalcante, graduanda em Ci√™ncia da Computa√ß√£o, marcando o in√≠cio da explora√ß√£o pr√°tica e te√≥rica sobre o framework no ecossistema Java.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h22m54s379.jpg" alt="" width="840">
</p>

Os objetivos principais desta sess√£o de aprendizado est√£o divididos em tr√™s pilares fundamentais:

1. **Defini√ß√£o e Utilidade:** Entender o conceito de Collections Framework e os motivos de sua utiliza√ß√£o.
2. **Composi√ß√£o:** Conhecer os elementos que formam a estrutura do framework.
3. **Hierarquia:** Visualizar como as interfaces e classes se organizam e se relacionam entre si.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h22m58s449.jpg" alt="" width="840">
</p>

Para acompanhar o curso de forma fluida, s√£o necess√°rios os seguintes pr√©-requisitos t√©cnicos e materiais:

* **Ambiente de Desenvolvimento:** Instala√ß√£o do Java JDK 11 e da IDE IntelliJ.
* **Versionamento:** Ter o Git instalado e possuir uma conta ativa no GitHub para gerenciar o c√≥digo-fonte.
* **Apoio Did√°tico:** Papel e caneta para anotar conceitos novos ou termos que exijam pesquisa posterior, auxiliando na fixa√ß√£o do conte√∫do.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h23m06s882.jpg" alt="" width="840">
</p>

Uma **Collection** √© um objeto projetado para agrupar m√∫ltiplos elementos (sejam vari√°veis primitivas ou objetos) em uma √∫nica unidade. Sua fun√ß√£o primordial √© permitir o armazenamento e o processamento de conjuntos de dados com alta efici√™ncia. Historicamente, antes do JDK 1.2 (Java 2), a linguagem possu√≠a poucas classes para cole√ß√µes e carecia da organiza√ß√£o estruturada de um framework, dependendo de estruturas mais r√≠gidas como os Arrays.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h23m10s607.jpg" alt="" width="840">
</p>

A estrutura do Collections Framework √© composta por tr√™s elementos fundamentais:

* **Interfaces:** Definem o "contrato" que as classes devem seguir. Ao implementar uma interface, a classe se obriga a fornecer o c√≥digo para os m√©todos definidos.
* **Implementa√ß√µes (Classes):** S√£o as materializa√ß√µes reais das interfaces, contendo a codifica√ß√£o espec√≠fica para o armazenamento dos dados.
* **Algoritmos:** Referem-se √† l√≥gica e √†s instru√ß√µes (m√©todos) utilizadas para resolver problemas e manipular os dados, como opera√ß√µes de busca, ordena√ß√£o, adi√ß√£o e remo√ß√£o.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h23m20s831.jpg" alt="" width="840">
</p>

O Collections Framework possui uma hierarquia bem definida de interfaces e classes.

Os principais grupos incluem:

* **Interface List:** Com implementa√ß√µes como `ArrayList`, `LinkedList` e `Vector`.
* **Interface Set:** Focada em elementos √∫nicos, incluindo `HashSet`, `LinkedHashSet` e `TreeSet` (que por sua vez implementa `NavigableSet`).
* **Interface Queue:** Representada por `PriorityQueue` e `LinkedList`.
* **Interface Map:** Embora perten√ßa ao framework, n√£o estende a interface `Collection` diretamente. Inclui `HashMap`, `LinkedHashMap`, `Hashtable` e `TreeMap`.

Al√©m disso, o framework disponibiliza classes utilit√°rias como `Arrays` e `Collections` para manipula√ß√£o dessas estruturas.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h23m26s003.jpg" alt="" width="840">
</p>

Para fixa√ß√£o do conte√∫do te√≥rico apresentado, sugere-se os seguintes exerc√≠cios:

1. Aprofundar o estudo sobre a tr√≠ade de composi√ß√£o: **Interfaces, Implementa√ß√µes e Algoritmos**.
2. Analisar detidamente a **Hierarquia do Collections Framework**, observando as rela√ß√µes de heran√ßa e implementa√ß√£o entre os componentes.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h23m27s543.jpg" alt="" width="840">
</p>

Para otimizar o desenvolvimento no IntelliJ IDEA, recomenda-se explorar atalhos de teclado e plugins que aumentam a produtividade:

* **Atalhos:** Podem ser consultados em guias de refer√™ncia para agilizar a codifica√ß√£o.
* **Plugins Recomendados:** `Git tool box` para integra√ß√£o com controle de vers√£o, `Key promoter` para aprender atalhos, `Rainbow Brackets` para visualiza√ß√£o de c√≥digo, al√©m de temas visuais como `Atom` e `One dark theme`.

Estes recursos preparam o ambiente para as pr√≥ximas aulas pr√°ticas, onde ser√° abordada a interface `List`.

## Parte 2 - Lists

### üü© V√≠deo 03 - Cole√ß√µes com itera√ß√µes ordenadas: Listas

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_03.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/8cab6dc3-3fec-43ed-96fa-0da97eca687a?autoplay=1

Esta aula introdut√≥ria sobre cole√ß√µes em Java foca na interface List, detalhando suas caracter√≠sticas principais, como permitir elementos duplicados e garantir a ordem de inser√ß√£o. O conte√∫do explora as implementa√ß√µes Vector, ArrayList e LinkedList, destacando suas diferen√ßas fundamentais e os cen√°rios ideais de uso para cada uma, com √™nfase na escolha entre ArrayList (para buscas) e LinkedList (para inser√ß√µes e exclus√µes).

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h41m14s091.jpg" alt="" width="840">
</p>

Nesta etapa inicial da aula, introduzimos o conceito de **Cole√ß√µes com itera√ß√µes ordenadas**, focando especificamente em **Listas** (`List`). Este conte√∫do faz parte do estudo introdut√≥rio sobre o ecossistema de *Collections* em Java, abordando estruturas que mant√™m a sequ√™ncia de inser√ß√£o dos elementos.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h41m19s016.jpg" alt="" width="840">
</p>

Os objetivos principais desta unidade did√°tica est√£o divididos em tr√™s pilares fundamentais:

1. **Caracter√≠sticas da interface List**: Compreender as propriedades b√°sicas da interface.
2. **Uso de ArrayList e LinkedList**: Entender como e quando utilizar cada uma dessas implementa√ß√µes.
3. **Principais m√©todos**: Conhecer as funcionalidades essenciais para manipula√ß√£o dessas cole√ß√µes.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-14h41m25s661.jpg" alt="" width="840">
</p>

A interface `java.util.List` define uma estrutura que permite **elementos duplicados** e garante a **ordem de inser√ß√£o**. Isso significa que os elementos ser√£o exibidos na mesma sequ√™ncia em que foram adicionados. Dentro da hierarquia do Java, a interface `List` estende `Collection`.

As implementa√ß√µes mais comuns possuem caracter√≠sticas distintas de performance e comportamento:

* **Vector**: Uma implementa√ß√£o pensada para contextos que envolvem *threads*, sendo considerada *thread-safe*.
* **ArrayList**: Utiliza um **array din√¢mico** internamente. √â a escolha preferencial para aplica√ß√µes que demandam mais **opera√ß√µes de pesquisa e acesso** aos dados. No entanto, a remo√ß√£o de elementos √© mais demorada, pois exige o deslocamento de bits na mem√≥ria.
* **LinkedList**: Utiliza uma estrutura de **lista duplamente ligada**. √â mais eficiente para **opera√ß√µes de inser√ß√£o e exclus√£o**, pois apenas altera os links de refer√™ncia entre os elementos, sem necessidade de deslocamento interno. Al√©m disso, implementa as interfaces `List` e `Deque`/`Queue`.


### üü© V√≠deo 04 - Conhecendo os m√©todos List - parte 1

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_04.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/5d2b4933-e791-4f57-b39e-cb044f774b75?autoplay=1

O v√≠deo apresenta um tutorial pr√°tico sobre a manipula√ß√£o de listas em Java, demonstrando a cria√ß√£o, adi√ß√£o, remo√ß√£o, substitui√ß√£o e verifica√ß√£o de elementos em uma lista de n√∫meros do tipo double. S√£o exploradas diferentes formas de inicializa√ß√£o de listas, incluindo o uso de ArrayList e a import√¢ncia de programar voltado para interfaces, al√©m de abordar conceitos como Generics e o Diamond Operator.

### Anota√ß√µes

Nesta aula pr√°tica, exploramos a interface `List` do Java atrav√©s da classe `ExemploList`. O objetivo √© resolver uma s√©rie de exerc√≠cios pr√°ticos que demonstram a manipula√ß√£o de cole√ß√µes de dados, especificamente utilizando uma lista de notas de um aluno.

#### üü° C√≥digo Completo

```java
package br.com.dio.collection.list;


import java.util.*;

class ExemploList {
    public static void main(String[] args) {
// Dada uma lista com 7 notas de um aluno [7, 8.5, 9.3, 5, 7, 0, 3.6], fa√ßa:

//      List notas = new ArrayList(); //antes do java 5
//      ArrayList<Double> notas = new ArrayList<>();
//      List<Double> notas = new ArrayList<>(Arrays.asList(7d, 8.5, 9.3, 5d, 7d, 0d, 3.6));
        /*List<Double> notas = Arrays.asList(7d, 8.5, 9.3, 5d, 7d, 0d, 3.6);
        notas.add(10d);
        System.out.println(notas);*/
        /*List<Double> notas = List.of(7d, 8.5, 9.3, 5d, 7d, 0d, 3.6);
        notas.add(1d);
        notas.remove(5d);
        System.out.println(notas);*/

        System.out.println("Crie uma lista e adicione as sete notas: ");

        List<Double> notas = new ArrayList<Double>(); //Generics(jdk 5) - Diamond Operator(jdk 7)
        notas.add(7.0);
        notas.add(8.5);
        notas.add(9.3);
        notas.add(5.0);
        notas.add(7.0);
        notas.add(0.0);
        notas.add(3.6);
        System.out.println(notas.toString());

        System.out.println("Exiba a posi√ß√£o da nota 5.0: " + notas.indexOf(5d));

        System.out.println("Adicione na lista a nota 8.0 na posi√ß√£o 4: ");
        notas.add(4, 8d);
        System.out.println(notas);

        System.out.println("Substitua a nota 5.0 pela nota 6.0: ");
        notas.set(notas.indexOf(5d), 6.0);
        System.out.println(notas);

        System.out.println("Confira se a nota 5.0 est√° na lista: " + notas.contains(5d));

        /*System.out.println("Exiba todas as notas na ordem em que foram informados: ");
        for (Double nota : notas) System.out.println(nota);*/

        System.out.println("Exiba a terceira nota adicionada: " + notas.get(2));
        System.out.println(notas.toString());

        System.out.println("Exiba a menor nota: " + Collections.min(notas));

        System.out.println("Exiba a maior nota: " + Collections.max(notas));

        Iterator<Double> iterator = notas.iterator();
        Double soma = 0d;
        while(iterator.hasNext()){
            Double next = iterator.next();
            soma += next;
        }
        System.out.println("Exiba a soma dos valores: " + soma);

        System.out.println("Exiba a m√©dia das notas: " + (soma/notas.size()));

        System.out.println("Remova a nota 0: ");
        notas.remove(0d);
        System.out.println(notas);

        System.out.println("Remova a nota da posi√ß√£o 0");
        notas.remove(0);
        System.out.println(notas);

        System.out.println("Remova as notas menores que 7 e exiba a lista: ");
        Iterator<Double> iterator1 = notas.iterator();
        while(iterator1.hasNext()) {
            Double next = iterator1.next();
            if(next < 7) iterator1.remove();
        }
        System.out.println(notas);

        /*System.out.println("Apague toda a lista");
        notas.clear();
        System.out.println(notas);
        */
        System.out.println("Confira se a lista est√° vazia: " + notas.isEmpty());

/*
Para voc√™: Resolva esses exerc√≠cios utilizando os m√©todos da implementa√ß√£o LinkedList:

        System.out.println("Crie uma lista chamada notas2 " +
                "e coloque todos os elementos da list Arraylist nessa nova lista: ");

        System.out.println("Mostre a primeira nota da nova lista sem remov√™-lo: ");

        System.out.println("Mostre a primeira nota da nova lista removendo-o: ");
*/

    }
}
```

#### Formas de Inicializa√ß√£o de Listas

A imagem apresenta diversas maneiras de instanciar e inicializar uma lista em Java, destacando a evolu√ß√£o da linguagem e as boas pr√°ticas de programa√ß√£o:

* **Antes do Java 5:** Utilizava-se a declara√ß√£o bruta sem Generics.
* **Generics e Diamond Operator:** Introduzidos para garantir a seguran√ßa de tipos. O Diamond Operator (`<>`), dispon√≠vel a partir do Java 7, simplifica a escrita ao n√£o exigir a repeti√ß√£o do tipo no lado direito da atribui√ß√£o.
* **Programa√ß√£o voltada √† Interface:** √â recomendado declarar a vari√°vel usando a interface `List` e instanci√°-la com uma implementa√ß√£o espec√≠fica, como `ArrayList`, para manter o c√≥digo flex√≠vel.
* **M√©todos Utilit√°rios:** O uso de `Arrays.asList` permite criar listas de forma r√°pida, por√©m, dependendo da implementa√ß√£o, a lista resultante pode ter tamanho fixo ou ser imut√°vel, impedindo opera√ß√µes de adi√ß√£o ou remo√ß√£o de elementos.

#### Opera√ß√µes Pr√°ticas com ArrayList

Ap√≥s a inicializa√ß√£o da lista `notas`, realizamos as seguintes opera√ß√µes:

1. **Adi√ß√£o de Elementos:** Utilizamos o m√©todo `add(Double)` para inserir as sete notas individualmente.
2. **Exibi√ß√£o da Posi√ß√£o:** O m√©todo `indexOf(5d)` √© utilizado para localizar o √≠ndice da primeira ocorr√™ncia da nota 5.0.
3. **Inser√ß√£o em Posi√ß√£o Espec√≠fica:** O m√©todo `add(int index, Double element)` insere um valor em uma posi√ß√£o determinada, deslocando os elementos subsequentes.
4. **Substitui√ß√£o:** O m√©todo `set(int index, Double element)` substitui o valor existente em uma posi√ß√£o espec√≠fica. No exemplo, a nota 5.0 foi substitu√≠da por 6.0.
5. **Verifica√ß√£o de Conte√∫do:** O m√©todo `contains(Object)` retorna um valor booleano indicando se o elemento est√° presente na lista.

```java
package br.com.dio.collection.list;

import java.util.*;

class ExemploList {
    public static void main(String[] args) {
        // Dada uma lista com 7 notas de um aluno (7, 8.5, 9.3, 5, 7, 0, 3.6), fa√ßa:

        System.out.println("Crie uma lista e adicione as sete notas: ");
        List<Double> notas = new ArrayList<Double>(); 
        notas.add(7.0);
        notas.add(8.5);
        notas.add(9.3);
        notas.add(5.0);
        notas.add(7.0);
        notas.add(0.0);
        notas.add(3.6);
        System.out.println(notas.toString());

        System.out.println("Exiba a posi√ß√£o da nota 5.0: " + notas.indexOf(5d));

        System.out.println("Adicione na lista a nota 8.0 na posi√ß√£o 4: ");
        notas.add(4, 8d);
        System.out.println(notas);

        System.out.println("Substitua a nota 5.0 pela nota 6.0: ");
        notas.set(notas.indexOf(5d), 6.0);
        System.out.println(notas);

        System.out.println("Confira se a nota 5.0 est√° na lista: " + notas.contains(5d));

        System.out.println("Exiba todas as notas na ordem em que foram informados: ");
        for (Double nota : notas) System.out.println(nota);

        System.out.println("Exiba a terceira nota adicionada: " + notas.get(2));
        System.out.println(notas.toString());
    }
}
```

### üü© V√≠deo 05 - Conhecendo os m√©todos List - parte 2

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_05.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/e383c216-1786-4505-80a6-f3f87db7238d?autoplay=1

Esta aula t√©cnica detalha a manipula√ß√£o de cole√ß√µes em Java, focando em opera√ß√µes essenciais da interface List e o uso de m√©todos utilit√°rios da classe Collections. O conte√∫do abrange desde a recupera√ß√£o de elementos por √≠ndice com o m√©todo get() e a identifica√ß√£o de valores extremos (m√≠nimo e m√°ximo) atrav√©s da interface Comparable, at√© a implementa√ß√£o de l√≥gicas customizadas de soma e remo√ß√£o condicional utilizando o Iterator para percorrer a lista de forma segura. Adicionalmente, s√£o explorados m√©todos de gerenciamento de estado da cole√ß√£o, como size() para medi√ß√£o de tamanho, clear() para esvaziamento e isEmpty() para verifica√ß√£o de conte√∫do, culminando em um desafio pr√°tico que incentiva a explora√ß√£o de implementa√ß√µes espec√≠ficas como o LinkedList e suas interfaces complementares.

### Anota√ß√µes

Esta etapa da aula foca na manipula√ß√£o de dados em uma `List` utilizando a linguagem Java. O exemplo demonstra como acessar elementos por √≠ndice, encontrar valores extremos (m√≠nimo e m√°ximo) e realizar opera√ß√µes de soma e m√©dia.

Para recuperar a terceira nota adicionada, utiliza-se o m√©todo `get(int index)`. Como as listas em Java possuem indexa√ß√£o baseada em zero, o √≠ndice `2` corresponde ao terceiro elemento. No exemplo visualizado, o retorno para esta opera√ß√£o √© a nota `9.3`.

Para identificar a menor e a maior nota, recorre-se √† classe utilit√°ria `Collections`. Os m√©todos `Collections.min(notas)` e `Collections.max(notas)` funcionam porque o tipo `Double` implementa a interface `Comparable`, que define a ordem natural dos elementos.

A soma dos valores √© realizada atrav√©s de um `Iterator`. O fluxo consiste em percorrer a lista com um la√ßo `while`, verificando a exist√™ncia de um pr√≥ximo elemento com `hasNext()` e recuperando-o com `next()` para acumul√°-lo em uma vari√°vel de controle. A m√©dia √© obtida dividindo-se o total acumulado pelo tamanho da lista, retornado pelo m√©todo `size()`.

```java
// Exemplo de opera√ß√µes demonstradas
System.out.println("Exiba a terceira nota adicionada: " + notas.get(2));
System.out.println("Exiba a menor nota: " + Collections.min(notas));
System.out.println("Exiba a maior nota: " + Collections.max(notas));

Iterator<Double> iterator = notas.iterator();
Double soma = 0d;
while(iterator.hasNext()){
    Double next = iterator.next();
    soma += next;
}
System.out.println("Exiba a soma dos valores: " + soma);
System.out.println("Exiba a m√©dia das notas: " + (soma/notas.size()));

```

Al√©m disso, a aula aborda a remo√ß√£o de elementos. √â importante notar a diferen√ßa entre `remove(int index)` e `remove(Object o)`. Ao lidar com `Double`, deve-se especificar o sufixo `d` (ex: `0d`) para garantir que o compilador entenda que se trata do objeto valor, e n√£o do √≠ndice da posi√ß√£o. Para remo√ß√µes condicionais (como notas menores que 7), utiliza-se o `iterator.remove()` para evitar erros de concorr√™ncia durante a itera√ß√£o. Por fim, os m√©todos `clear()` e `isEmpty()` s√£o apresentados para esvaziar a lista e verificar seu estado, respectivamente.

### üü© V√≠deo 06 - Ordena√ß√£o de elementos em uma cole√ß√£o List - parte 1

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_06.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/72c54080-cbe0-4a60-85b4-d15fb46fb512?autoplay=1

O v√≠deo demonstra a cria√ß√£o e manipula√ß√£o de listas em Java, focando na organiza√ß√£o de objetos do tipo "Gato" com atributos de nome, idade e cor. S√£o apresentados m√©todos para adicionar elementos a uma lista, exibir a lista em sua ordem de inser√ß√£o e embaralhar a ordem dos elementos utilizando a classe Collections.

### Anota√ß√µes

Nesta aula, exploramos o processo de ordena√ß√£o de elementos em uma `List` utilizando a linguagem Java. O exemplo pr√°tico consiste em organizar uma lista de objetos do tipo `Gato` com base em atributos como nome, idade e cor.

#### üî¥ C√≥digo completo

```java
package br.com.dio.collection.list;

/* Dadas as seguintes informa√ß√µes sobre meus gatos, crie uma lista 
   e ordene esta lista exibindo: (nome - idade - cor); 

   Gato 1 = nome: Jon, idade: 18, cor: preto 
   Gato 2 = nome: Simba, idade: 6, cor: tigrado 
   Gato 3 = nome: Jon, idade: 12, cor: amarelo 
*/

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ExemploOrdenacaoList {
    public static void main(String[] args) {

        // Cria√ß√£o da lista de gatos utilizando uma sintaxe de inicializa√ß√£o com chaves duplas 
        List<Gato> meusGatos = new ArrayList<>(){{
            add(new Gato("Jon", 12, "preto")); // Adiciona o primeiro objeto Gato 
            add(new Gato("Simba", 6, "tigrado")); // Adiciona o segundo objeto Gato 
            add(new Gato("Jon", 18, "amarelo")); // Adiciona o terceiro objeto Gato 
        }};

        // Exibi√ß√£o na ordem de inser√ß√£o: a List mant√©m os elementos conforme foram adicionados 
        System.out.println("--\tOrdem de Inser√ß√£o\t---");
        System.out.println(meusGatos); // Imprime a lista (usa o m√©todo toString da classe Gato) 

        // Ordem aleat√≥ria: utiliza o m√©todo shuffle da classe Collections para "bagun√ßar" a lista 
        System.out.println("--\tOrdem aleat√≥ria\t---");
        Collections.shuffle(meusGatos); 
        System.out.println(meusGatos);

        // Ordem Natural: utiliza o Comparable implementado na classe Gato (ordena√ß√£o por Nome) 
        System.out.println("--\tOrdem Natural (Nome)\t---");
        Collections.sort(meusGatos); // O m√©todo sort precisa que a classe implemente Comparable 
        System.out.println(meusGatos);

        // Ordem por Idade: utiliza a interface Comparator externa para definir um crit√©rio diferente 
        System.out.println("--\tOrdem Idade\t---");
        // meusGatos.sort(new ComparatorIdade()); // Forma alternativa de chamar o sort diretamente na lista 
        Collections.sort(meusGatos, new ComparatorIdade()); 
        System.out.println(meusGatos);

        // Ordem por Cor: utiliza outro Comparator customizado para comparar strings de cores 
        System.out.println("--\tOrdem cor\t---");
        meusGatos.sort(new ComparatorCor()); 
        System.out.println(meusGatos);

        // Ordem Nome/Cor/Idade: ordena√ß√£o composta. Se nomes forem iguais, olha cor; se cores forem iguais, olha idade 
        System.out.println("--\tOrdem Nome/Cor/Idade\t---");
        meusGatos.sort(new ComparatorNomeCorIdade()); 
        System.out.println(meusGatos);
    }
}

// Classe Gato implementando Comparable para definir a ordem natural de compara√ß√£o 
class Gato implements Comparable<Gato>{
    private String nome;
    private Integer idade;
    private String cor;

    // Construtor para inicializar os atributos do gato 
    public Gato(String nome, Integer idade, String cor) {
        this.nome = nome;
        this.idade = idade;
        this.cor = cor;
    }

    // M√©todos Getter para acessar atributos privados 
    public String getNome() { return nome; }
    public Integer getIdade() { return idade; }
    public String getCor() { return cor; }

    // Sobrescrita do toString para exibir os dados do objeto em vez do endere√ßo de mem√≥ria 
    @Override
    public String toString() {
        return "{" +
                "nome='" + nome + '\'' +
                ", idade=" + idade +
                ", cor='" + cor + '\'' +
                '}';
    }

    // Implementa√ß√£o do compareTo (obrigat√≥rio pelo Comparable) para comparar nomes ignorando mai√∫sculas 
    @Override
    public int compareTo(Gato gato) {
        return this.getNome().compareToIgnoreCase(gato.getNome()); // Retorna 0 (iguais), 1 (maior) ou -1 (menor) 
    }
}

// Classe Comparator para ordenar especificamente por idade 
class ComparatorIdade implements Comparator<Gato> {
    @Override
    public int compare(Gato g1, Gato g2) {
        return Integer.compare(g1.getIdade(), g2.getIdade()); // Usa o m√©todo de compara√ß√£o da classe Integer 
    }
}

// Classe Comparator para ordenar especificamente por cor 
class ComparatorCor implements Comparator<Gato> {
    @Override
    public int compare(Gato g1, Gato g2) {
        return g1.getCor().compareToIgnoreCase(g2.getCor()); // Compara strings alfabeticamente 
    }
}

// Classe Comparator para m√∫ltiplos crit√©rios de desempate 
class ComparatorNomeCorIdade implements Comparator<Gato> {
    @Override
    public int compare(Gato g1, Gato g2) {
        // Primeiro crit√©rio: Nome 
        int nome = g1.getNome().compareToIgnoreCase(g2.getNome());
        if (nome != 0) return nome; // Se os nomes forem diferentes, j√° define a ordem aqui 

        // Segundo crit√©rio (desempate): Cor 
        int cor = g1.getCor().compareToIgnoreCase(g2.getCor());
        if(cor !=0) return cor; // Se as cores forem diferentes, define a ordem aqui 

        // Terceiro crit√©rio (desempate final): Idade 
        return Integer.compare(g1.getIdade(), g2.getIdade());
    }
}
```

#### Defini√ß√£o do Modelo e Estrutura Inicial

Para iniciar, √© definida a classe `Gato`, que implementa a interface `Comparable` para estabelecer uma **ordem natural** de compara√ß√£o. A classe possui os atributos `nome`, `idade` e `cor`, acompanhados de seus respectivos m√©todos construtores e getters.

#### Instancia√ß√£o e Ordem de Inser√ß√£o

Os gatos s√£o adicionados a uma `ArrayList` utilizando o m√©todo `add`. Por padr√£o, a `List` mant√©m os elementos na **ordem de inser√ß√£o**. Para visualizar os dados corretamente em vez do endere√ßo de mem√≥ria, o m√©todo `toString()` √© sobrescrevido na classe.

#### M√©todos de Ordena√ß√£o

A aula demonstra diferentes formas de manipular a ordem da lista:

* **Ordem Aleat√≥ria**: Utiliza-se `Collections.shuffle(meusGatos)` para embaralhar os elementos.
* **Ordem Natural**: Implementada atrav√©s do m√©todo `compareTo` na classe `Gato`, comparando os nomes ignorando mai√∫sculas e min√∫sculas (`compareToIgnoreCase`). A ordena√ß√£o √© executada com `Collections.sort(meusGatos)`.
* **Ordena√ß√£o por Atributos Espec√≠ficos (Customizada)**: Para crit√©rios que fogem √† ordem natural, criam-se classes que implementam a interface `Comparator`.

#### Implementa√ß√£o de Comparators

Foram criadas classes espec√≠ficas para lidar com diferentes l√≥gicas de compara√ß√£o:

* **ComparatorIdade**: Compara os gatos pela idade de forma num√©rica.
* **ComparatorCor**: Compara as cores das Strings.
* **ComparatorNomeCorIdade**: Uma ordena√ß√£o composta que verifica primeiro o nome; se forem iguais, verifica a cor; e por fim, a idade, garantindo um crit√©rio de desempate preciso.


### üü© V√≠deo 07 - Ordena√ß√£o de elementos em uma cole√ß√£o List - parte 2

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_07.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/5bdd9534-1fc4-4612-9309-383812ec570e?autoplay=1

Esta aula detalha o uso da interface Comparator em Java para a ordena√ß√£o personalizada de listas de objetos, complementando a interface Comparable. Atrav√©s da implementa√ß√£o do m√©todo compare, demonstra-se como criar classes espec√≠ficas para ordenar atributos como idade (utilizando Integer.compare) e cor (utilizando compareToIgnoreCase para Strings). O v√≠deo explora ainda a cria√ß√£o de ordena√ß√µes compostas, onde m√∫ltiplos crit√©rios ‚Äî nome, cor e idade ‚Äî s√£o encadeados como n√≠veis de desempate, e apresenta a flexibilidade de aplicar esses ordenadores tanto via Collections.sort quanto pelo m√©todo sort da pr√≥pria lista.

### Anota√ß√µes

Nesta aula, exploramos a ordena√ß√£o de listas em Java utilizando a interface `Comparator`. Diferente da interface `Comparable` (que define uma ordem natural √∫nica para a classe), o `Comparator` permite criar m√∫ltiplas estrat√©gias de ordena√ß√£o externas √† classe principal.

Abaixo, detalhamos as implementa√ß√µes para ordenar uma lista de objetos do tipo `Gato` por diferentes atributos: idade, cor e uma composi√ß√£o de m√∫ltiplos crit√©rios.

#### 1. Ordena√ß√£o por Idade

Para ordenar por idade, implementamos a classe `ComparatorIdade`. Como o atributo `idade` √© um `Integer`, utilizamos o m√©todo est√°tico `Integer.compare()`, que facilita a compara√ß√£o entre dois valores inteiros, retornando um valor negativo se o primeiro for menor, zero se forem iguais, ou positivo se for maior.

```java
class ComparatorIdade implements Comparator<Gato> {
    @Override
    public int compare(Gato g1, Gato g2) {
        return Integer.compare(g1.getIdade(), g2.getIdade());
    }
}

```

#### 2. Ordena√ß√£o por Cor

Para a ordena√ß√£o por cor, a classe `ComparatorCor` utiliza o m√©todo `compareToIgnoreCase` da classe `String`. Isso garante que a compara√ß√£o alfab√©tica ignore a diferen√ßa entre letras mai√∫sculas e min√∫sculas.

```java
class ComparatorCor implements Comparator<Gato> {
    @Override
    public int compare(Gato g1, Gato g2) {
        return g1.getCor().compareToIgnoreCase(g2.getCor());
    }
}

```

#### 3. Ordena√ß√£o Composta (Nome/Cor/Idade)

Quando precisamos de m√∫ltiplos crit√©rios de desempate, implementamos uma l√≥gica encadeada na classe `ComparatorNomeCorIdade`. O sistema primeiro compara os nomes; se forem diferentes, define a ordem por eles. Se os nomes forem iguais (retorno 0), o c√≥digo passa a comparar as cores. Se as cores tamb√©m forem id√™nticas, o crit√©rio final de desempate √© a idade.

```java
class ComparatorNomeCorIdade implements Comparator<Gato> {
    @Override
    public int compare(Gato g1, Gato g2) {
        int nome = g1.getNome().compareToIgnoreCase(g2.getNome());
        if (nome != 0) return nome;

        int cor = g1.getCor().compareToIgnoreCase(g2.getCor());
        if (cor != 0) return cor;

        return Integer.compare(g1.getIdade(), g2.getIdade());
    }
}

```

#### Execu√ß√£o da Ordena√ß√£o

Para aplicar essas ordena√ß√µes √† lista `meusGatos`, podemos utilizar tanto o m√©todo `Collections.sort(lista, comparator)` quanto o m√©todo `.sort(comparator)` dispon√≠vel diretamente na interface `List` a partir do Java 8.


### üü© V√≠deo 08 - Exerc√≠cios Propostos - List

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_08.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/b58befe2-06fb-43fa-9817-5e897cfd9797?autoplay=1

Esta aula encerra o m√≥dulo sobre a interface List com a proposi√ß√£o de dois exerc√≠cios pr√°ticos focados em l√≥gica de programa√ß√£o e manipula√ß√£o de cole√ß√µes. O primeiro desafio requer o armazenamento de temperaturas m√©dias semestrais para o c√°lculo de uma m√©dia geral e a identifica√ß√£o dos meses com valores acima desse √≠ndice, apresentados por extenso. O segundo exerc√≠cio utiliza listas para classificar a participa√ß√£o em um crime com base em cinco perguntas interrogativas, categorizando o usu√°rio como inocente, suspeito, c√∫mplice ou assassino conforme o volume de respostas positivas. O v√≠deo conclui incentivando a resolu√ß√£o aut√¥noma antes da consulta ao reposit√≥rio de solu√ß√µes e antecipa que o dom√≠nio de List facilitar√° significativamente o aprendizado da pr√≥xima interface, Set.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-17h04m19s483.jpg" alt="" width="840">
</p>

Esta imagem apresenta o primeiro exerc√≠cio proposto para fixa√ß√£o do conte√∫do sobre listas. O objetivo √© exercitar a l√≥gica de programa√ß√£o atrav√©s da manipula√ß√£o de cole√ß√µes e c√°lculos simples. O desafio consiste em desenvolver um programa que:

1. **Entrada de Dados**: Receba a temperatura m√©dia dos seis primeiros meses do ano.
2. **Armazenamento**: Guarde esses valores em uma lista.
3. **Processamento**: Calcule a m√©dia aritm√©tica semestral dessas temperaturas.
4. **Sa√≠da**: Exiba quais temperaturas ficaram acima da m√©dia calculada e identifique o m√™s correspondente por extenso (ex: 1 - Janeiro, 2 - Fevereiro).

Para a resolu√ß√£o, ser√° necess√°rio percorrer a lista para realizar a soma e o c√°lculo da m√©dia, e posteriormente filtrar os dados para a exibi√ß√£o dos resultados condicionais.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-17h04m24s655.jpg" alt="" width="840">
</p>

O segundo exerc√≠cio proposto foca na utiliza√ß√£o de listas para classifica√ß√£o baseada em m√∫ltiplas entradas. O programa deve simular um interrogat√≥rio sobre um crime, realizando cinco perguntas espec√≠ficas:

* "Telefonou para a v√≠tima?"
* "Esteve no local do crime?"
* "Mora perto da v√≠tima?"
* "Devia para a v√≠tima?"
* "J√° trabalhou com a v√≠tima?"

As respostas (positivas ou negativas) devem ser armazenadas em uma lista. A classifica√ß√£o final do indiv√≠duo depender√° da quantidade de respostas positivas coletadas:

* **2 respostas**: Suspeita
* **3 a 4 respostas**: C√∫mplice
* **5 respostas**: Assassina
* **Menos de 2**: Inocente

Este exerc√≠cio visa praticar a filtragem de elementos dentro de uma lista e a aplica√ß√£o de estruturas condicionais encadeadas.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-25-17h04m27s446.jpg" alt="" width="840">
</p>

Nesta imagem, s√£o apresentados os canais de refer√™ncia para consulta das resolu√ß√µes dos exerc√≠cios e contato com a instrutora. √â refor√ßado que n√£o existe uma √∫nica solu√ß√£o correta em programa√ß√£o, incentivando o aluno a tentar resolver os desafios de forma aut√¥noma antes de comparar com o c√≥digo de refer√™ncia dispon√≠vel no GitHub.

**Redes Sociais e Reposit√≥rio:**

* **GitHub**: [https://github.com/cami-la/curso-dio-intro-collections](https://github.com/cami-la/curso-dio-intro-collections)
* **LinkedIn**: [https://www.linkedin.com/in/cami-la/](https://www.linkedin.com/in/cami-la/)
* **Instagram**: @camimi_la

Al√©m do reposit√≥rio, o suporte para d√∫vidas e discuss√µes pode ser realizado atrav√©s do f√≥rum da plataforma DIO ou pela comunidade no Discord. Com a conclus√£o deste m√≥dulo de `List`, o pr√≥ximo t√≥pico abordado ser√° a interface `Set`.      

## Parte 3 - Set

### üü© V√≠deo 09 - Cole√ß√µes com singularidade: Set

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_09.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/f9fb3d0e-8999-4a2a-8735-24144ae40d8e?autoplay=1

Este v√≠deo apresenta uma introdu√ß√£o detalhada √† interface Set do framework de Collections do Java, destacando suas caracter√≠sticas fundamentais, como a proibi√ß√£o de elementos duplicados e a aus√™ncia de √≠ndices. O conte√∫do explora as tr√™s principais implementa√ß√µes ‚Äî HashSet, LinkedHashSet e TreeSet ‚Äî comparando seus comportamentos em termos de ordena√ß√£o, performance e permiss√£o de valores nulos, servindo como um guia pr√°tico para desenvolvedores escolherem a estrutura de dados mais adequada √†s suas necessidades.

 ### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-11h13m18s829.jpg" alt="" width="840">
</p>

Nesta introdu√ß√£o √† segunda aula do curso de Collections, iniciamos a etapa focada em **Cole√ß√µes Singulares: Set**. O objetivo central √© explorar como essa interface se comporta dentro do ecossistema Java e quais s√£o as suas particularidades em rela√ß√£o a outras estruturas de dados.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-11h13m21s898.jpg" alt="" width="840">
</p>

Os objetivos desta aula est√£o divididos em dois pontos principais:

1. **Caracter√≠sticas da interface Set:** Compreender as regras fundamentais que regem todas as cole√ß√µes do tipo Set.
2. **Implementa√ß√µes espec√≠ficas:** Entender o funcionamento, as diferen√ßas e o momento ideal para utilizar **HashSet**, **LinkedHashSet** e **TreeSet**, al√©m de conhecer seus m√©todos essenciais.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-11h13m28s669.jpg" alt="" width="840">
</p>

A interface `java.util.Set` possui caracter√≠sticas marcantes que a definem: **n√£o permite elementos duplicados** e **n√£o possui √≠ndice**. A aus√™ncia de √≠ndice significa que n√£o √© poss√≠vel recuperar elementos por uma posi√ß√£o num√©rica (como o m√©todo `get(int index)` da interface List) ou realizar substitui√ß√µes baseadas em posi√ß√£o.

A hierarquia de classes e interfaces define o comportamento de cada implementa√ß√£o:

* **HashSet:** Implementa a interface `Set` diretamente. Internamente, utiliza uma `HashMap` para armazenar elementos. N√£o garante nenhuma ordem (a disposi√ß√£o √© aleat√≥ria), oferece a melhor performance e permite um elemento nulo.
* **LinkedHashSet:** Estende `HashSet` e mant√©m a **ordem de inser√ß√£o** dos elementos, utilizando internamente uma `LinkedHashMap`. Sua performance √© intermedi√°ria e tamb√©m permite um elemento nulo.
* **TreeSet:** Implementa `NavigableSet` (que estende `SortedSet`). Utiliza uma `TreeMap` para manter os elementos em sua **ordem natural** (alfab√©tica ou num√©rica) ou atrav√©s de um `Comparator`. √â a implementa√ß√£o com performance mais lenta e **n√£o permite elementos nulos**.


### üü© V√≠deo 10 - Conhecendo os m√©todos Set

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_10.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/e28b9311-8659-4fe4-a4e1-f4ce47a9210d?autoplay=1

O v√≠deo apresenta uma compara√ß√£o pr√°tica entre as interfaces List e Set. Embora ambas herdem de Collection, o Set possui caracter√≠sticas √∫nicas: n√£o permite elementos duplicados e, em sua implementa√ß√£o padr√£o (HashSet), n√£o garante a ordem dos elementos. A aula demonstra como realizar opera√ß√µes comuns (soma, m√©dia, busca, remo√ß√£o) e como escolher a implementa√ß√£o correta de acordo com a necessidade de ordena√ß√£o.

### Anota√ß√µes

Nesta aula, exploramos a implementa√ß√£o da interface `Set` em Java, utilizando como base um exerc√≠cio pr√°tico com notas de alunos. O objetivo principal √© destacar as diferen√ßas fundamentais entre `List` e `Set`, observando como os conjuntos lidam com a ordena√ß√£o e a duplicidade de elementos. 

```java
package br.com.dio.collection.set;


import java.util.*;

public class ExemploSet {
    public static void main(String[] args) {
// Dada uma lista com 7 notas de um aluno [7, 8.5, 9.3, 5, 7, 0, 3.6], fa√ßa:

//      Set notas = new HashSet(); //antes do java 5
//      HashSet<Double> notas = new HashSet<>();
//      Set<Double> notas = new HashSet<>(); //Generics(jdk 5) - Diamont Operator(jdk 7)
/*      Set<Double> notas = Set.of(7d, 8.5, 9.3, 5d, 7d, 0d, 3.6);
        notas.add(1d);
        notas.remove(5d);
        System.out.println(notas);
*/

        System.out.println("Crie um conjunto e adicione as notas: ");
        Set<Double> notas = new HashSet<>(Arrays.asList(7d, 8.5, 9.3, 5d, 7d, 0d, 3.6));
        System.out.println(notas.toString());

//        System.out.println("Exiba a posi√ß√£o da nota 5.0: ");

//        System.out.println("Adicione na lista a nota 8.0 na posi√ß√£o 4: ");

//        System.out.println("Substitua a nota 5.0 pela nota 6.0: ");

        System.out.println("Confira se a nota 5.0 est√° no conjunto: " + notas.contains(5d));

//        System.out.println("Exiba a terceira nota adicionada: ");

        System.out.println("Exiba a menor nota: " + Collections.min(notas));

        System.out.println("Exiba a maior nota: " + Collections.max(notas));

        Iterator<Double> iterator = notas.iterator();
        Double soma = 0.0;
        while(iterator.hasNext()) {
            Double next = iterator.next();
            soma += next;
        }
        System.out.println("Exiba a soma dos valores: " + soma);

        System.out.println("Exiba a m√©dia das notas: " + (soma/ notas.size()));

        System.out.println("Remova a nota 0: ");
        notas.remove(0d);
        System.out.println(notas);

//        System.out.println("Remova a nota da posi√ß√£o 0");

        System.out.println("Remova as notas menores que 7 e exiba a lista: ");
        Iterator<Double> iterator1 = notas.iterator();
        while(iterator1.hasNext()){
            Double next = iterator1.next();
            if (next < 7) iterator1.remove();
        }
        System.out.println(notas);

        System.out.println("Exiba todas as notas na ordem em que foram informados: ");
        Set<Double> notas2 = new LinkedHashSet<>();
        notas2.add(7d);
        notas2.add(8.5);
        notas2.add(9.3);
        notas2.add(5d);
        notas2.add(7d);
        notas2.add(0d);
        notas2.add(3.6);
        System.out.println(notas2);

        System.out.println("Exiba todas as notas na ordem crescente: ");
        Set<Double> notas3 = new TreeSet<>(notas2);
        System.out.println(notas3);

        System.out.println("Apague todo o conjunto");
        notas.clear();

        System.out.println("Confira se o conjunto est√° vazio: " + notas.isEmpty());
        System.out.println("Confira se o conjunto 2 est√° vazio: " + notas2.isEmpty());
        System.out.println("Confira se o conjunto 3 est√° vazio: " + notas3.isEmpty());

    }
}
```

#### Inicializa√ß√£o e Caracter√≠sticas do HashSet

A imagem demonstra diferentes formas de inicializar um `Set`, desde sintaxes anteriores ao Java 5 at√© o uso de **Generics** e do **Diamond Operator**. Na pr√°tica principal, utilizamos a implementa√ß√£o `HashSet`. 

Ao adicionar os elementos `[7, 8.5, 9.3, 5, 7, 0, 3.6]` ao `HashSet`, observamos comportamentos espec√≠ficos: 

* **N√£o ordena√ß√£o:** Os elementos s√£o exibidos em ordem aleat√≥ria, pois o `HashSet` n√£o garante a ordem de inser√ß√£o.
* **Unicidade:** O valor `7` (repetido na lista original) √© inserido apenas uma vez no conjunto. [00:01:00, cite: 17, 116]

#### Limita√ß√µes de Acesso por √çndice

Diferente das listas, a interface `Set` (especialmente no `HashSet`) n√£o permite buscas ou manipula√ß√µes baseadas em posi√ß√£o ou √≠ndice.

* N√£o existe o m√©todo `get(index)`, impossibilitando exibir a "terceira nota adicionada" ou a "nota na posi√ß√£o 4".
* N√£o √© poss√≠vel substituir um valor em uma posi√ß√£o espec√≠fica via m√©todo `set`.

#### Opera√ß√µes com Collections e Iterator

Apesar das restri√ß√µes de √≠ndice, podemos realizar opera√ß√µes comuns a todas as `Collection`:

* **Busca:** O m√©todo `contains(5d)` retorna `true` se o elemento estiver presente. [00:02:30, cite: 42, 43]
* **An√°lise:** M√©todos como `Collections.min(notas)` e `Collections.max(notas)` funcionam normalmente para encontrar os valores extremos. [00:02:30, 00:03:00, cite: 50, 54]
* **Soma e M√©dia:** Utilizamos um `Iterator` para percorrer o conjunto e acumular os valores na vari√°vel `soma`, dividindo posteriormente pelo `size()` para obter a m√©dia. [00:03:30, 00:04:30, cite: 57, 58, 81, 82]
* **Remo√ß√£o Condicional:** Tamb√©m via `Iterator`, √© poss√≠vel remover elementos que atendam a um crit√©rio (ex: notas menores que 7). [00:05:30, cite: 87, 96]

#### Preservando a Ordem e Ordena√ß√£o Natural

Para contornar a natureza aleat√≥ria do `HashSet`, utilizamos outras implementa√ß√µes:

* **LinkedHashSet:** Mant√©m a ordem em que os elementos foram informados. [00:06:00, cite: 106]
* **TreeSet:** Armazena os elementos seguindo sua ordem natural (crescente). 


### üü© V√≠deo 11 - Ordena√ß√£o de elementos em uma cole√ß√£o Set

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_11.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/2b0fd52a-7424-4bf7-89be-376483007b3d?autoplay=1

Este guia resume a aula pr√°tica sobre como criar, manipular e ordenar cole√ß√µes do tipo Set em Java, utilizando como exemplo um conjunto de s√©ries de TV. O foco principal √© entender as diferen√ßas entre HashSet, LinkedHashSet e TreeSet, al√©m da implementa√ß√£o das interfaces Comparable e Comparator.

### Anota√ß√µes

Nesta aula, exploramos a ordena√ß√£o de conjuntos (`Set`) em Java utilizando diferentes implementa√ß√µes e crit√©rios. O objetivo inicial √© criar um conjunto de s√©ries favoritas contendo nome, g√™nero e tempo de epis√≥dio, para ent√£o exibir esses dados em ordens variadas: aleat√≥ria, de inser√ß√£o e natural. 

```java
package br.com.dio.collection.set;

/*Dadas as seguintes informa√ß√µes sobre minhas s√©ries favoritas,
crie um conjunto e ordene este conjunto exibindo:
(nome - genero - tempo de epis√≥dio);

S√©rie 1 = Nome: got, genero: fantasia, tempoEpisodio: 60
S√©rie 2 = nome: dark, genero: drama, tempoEpisodio: 60
S√©rie 3 = nome: that '70s show, genero: com√©dia, tempoEpisodio: 25
*/

import java.util.*;

public class ExemploOrdenacaoSet {
    public static void main(String[] args) {

        System.out.println("--\tOrdem aleat√≥ria\t--");
        Set<Serie> minhasSeries = new HashSet<>(){{
            add(new Serie("got", "fantasia", 60));
            add(new Serie("dark", "drama", 60));
            add(new Serie("that '70s show", "com√©dia", 25));
        }};
        for (Serie serie: minhasSeries) System.out.println(serie.getNome() + " - "
                + serie.getGenero() + " - " + serie.getTempoEpisodio());

        System.out.println("--\tOrdem inser√ß√£o\t--");
        Set<Serie> minhasSeries1 = new LinkedHashSet<>() {{
            add(new Serie("got", "fantasia", 60));
            add(new Serie("dark", "drama", 60));
            add(new Serie("that '70s show", "com√©dia", 25));
        }};
        for (Serie serie: minhasSeries1) System.out.println(serie.getNome() + " - "
                + serie.getGenero() + " - " + serie.getTempoEpisodio());

        System.out.println("--\tOrdem natural (TempoEpisodio)\t--");
        Set<Serie> minhasSeries2 = new TreeSet<>(minhasSeries1);
        for (Serie serie: minhasSeries2) System.out.println(serie.getNome() + " - "
                + serie.getGenero() + " - " + serie.getTempoEpisodio());

        System.out.println("--\tOrdem Nome/G√™nero/TempoEpisodio\t--");
        Set<Serie> minhasSeries3 = new TreeSet<>(new ComparatorNomeGeneroTempoEpisodio());
        minhasSeries3.addAll(minhasSeries);
        for (Serie serie: minhasSeries3) System.out.println(serie.getNome() + " - "
                + serie.getGenero() + " - " + serie.getTempoEpisodio());

//Pra voc√™
/*        System.out.println("--\tOrdem g√™nero\t--");

          System.out.println("--\tOrdem Tempo Epis√≥dio\t--");
 */

    }
}

class Serie implements Comparable<Serie>{
    private String nome;
    private String genero;
    private Integer tempoEpisodio;

    public Serie(String nome, String genero, Integer tempoEpisodio) {
        this.nome = nome;
        this.genero = genero;
        this.tempoEpisodio = tempoEpisodio;
    }

    public String getNome() {
        return nome;
    }

    public String getGenero() {
        return genero;
    }

    public Integer getTempoEpisodio() {
        return tempoEpisodio;
    }

    @Override
    public String toString() {
        return "{" +
                "nome='" + nome + '\'' +
                ", genero='" + genero + '\'' +
                ", tempoEpisodio=" + tempoEpisodio +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Serie serie = (Serie) o;
        return nome.equals(serie.nome) && genero.equals(serie.genero) && tempoEpisodio.equals(serie.tempoEpisodio);
    }

    @Override
    public int hashCode() {
        return Objects.hash(nome, genero, tempoEpisodio);
    }

    @Override
    public int compareTo(Serie serie) {
        int tempoEpisodio = Integer.compare(this.getTempoEpisodio(), serie.getTempoEpisodio());
        if (tempoEpisodio != 0) return tempoEpisodio;

        return this.getGenero().compareTo(serie.getGenero());
    }
}

class ComparatorNomeGeneroTempoEpisodio implements Comparator<Serie>{

    @Override
    public int compare(Serie s1, Serie s2) {
        int nome = s1.getNome().compareTo(s2.getNome());
        if (nome != 0) return nome;

        int genero = s1.getGenero().compareTo(s2.getGenero());
        if (genero != 0) return genero;

        return Integer.compare(s1.getTempoEpisodio(), s2.getTempoEpisodio());
    }
}
```

#### Defini√ß√£o da Classe Base e Ordem Aleat√≥ria

Para manipular os dados, criamos a classe `Serie` com os atributos `nome`, `genero` e `tempoEpisodio`. √â fundamental sobrescrever os m√©todos `equals` e `hashCode`, garantindo que o conjunto identifique corretamente objetos √∫nicos, especialmente ao utilizar implementa√ß√µes "hash". 

Utilizamos o `HashSet` para a primeira exibi√ß√£o. Esta implementa√ß√£o n√£o garante nenhuma ordem espec√≠fica, resultando em uma disposi√ß√£o aleat√≥ria dos elementos ao imprimir o conjunto. 

```java
public class ExemploOrdenacaoSet {
    public static void main(String[] args) {
        System.out.println("--\tordem aleat√≥ria\t--");
        Set<Serie> minhasSeries = new HashSet<>(){{
            add(new Serie("got", "fantasia", 68));
            add(new Serie("dark", "drama", 60));
            add(new Serie("that '70s show", "com√©dia", 25));
        }};
        for (Serie serie : minhasSeries) System.out.println(serie.getNome() + " - " 
            + serie.getGenero() + " - " + serie.getTempoEpisodio());
    }
}

```

#### Ordem de Inser√ß√£o e Ordem Natural

Para manter os elementos na ordem em que foram adicionados, utilizamos o `LinkedHashSet`. J√° para a **ordem natural**, empregamos o `TreeSet`. Para que o `TreeSet` funcione, a classe `Serie` deve implementar a interface `Comparable`, definindo o crit√©rio de compara√ß√£o (neste caso, o `tempoEpisodio`). 

Um detalhe importante no `TreeSet` √© que, se dois objetos possuem o mesmo valor no crit√©rio de compara√ß√£o (como s√©ries com o mesmo tempo de epis√≥dio), o `Set` descartar√° um deles por consider√°-los iguais. Para evitar isso, adicionamos um crit√©rio de desempate, como o g√™nero. 

```java
// Implementa√ß√£o do Comparable na classe Serie
public int compareTo(Serie serie) {
    int tempoEpisodio = Integer.compare(this.getTempoEpisodio(), serie.getTempoEpisodio());
    if (tempoEpisodio != 0) return tempoEpisodio;
    return this.getGenero().compareTo(serie.getGenero());
}

```

#### Ordena√ß√£o Personalizada com Comparator

Quando precisamos de uma ordena√ß√£o que foge √† regra natural, criamos uma classe que implementa `Comparator`. No exemplo `ComparatorNomeGeneroTempoEpisodio`, definimos uma hierarquia de compara√ß√£o: primeiro pelo nome, depois pelo g√™nero e, por fim, pelo tempo de epis√≥dio. 

```java
class ComparatorNomeGeneroTempoEpisodio implements Comparator<Serie> {
    @Override
    public int compare(Serie s1, Serie s2) {
        int nome = s1.getNome().compareTo(s2.getNome());
        if (nome != 0) return nome;

        int genero = s1.getGenero().compareTo(s2.getGenero());
        if (genero != 0) return genero;

        return Integer.compare(s1.getTempoEpisodio(), s2.getTempoEpisodio());
    }
}

```

Para aplicar essa l√≥gica, passamos uma inst√¢ncia do comparador no construtor do `TreeSet` e utilizamos o m√©todo `addAll` para povoar o novo conjunto organizado. 


### üü© V√≠deo 12 - Exerc√≠cios Propostos Set

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_12.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/fcf392c8-9c8a-45dd-8146-b64d0e342ff0?autoplay=1

Este m√≥dulo foca na aplica√ß√£o pr√°tica dos conceitos de conjuntos (Set) na linguagem Java. O instrutor prop√µe dois desafios principais que visam consolidar o conhecimento sobre manipula√ß√£o, ordena√ß√£o e filtragem de dados que n√£o permitem duplicidade.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-16h28m53s076.jpg" alt="" width="840">
</p>

Esta imagem apresenta uma s√©rie de exerc√≠cios propostos para consolidar o conhecimento sobre a interface `Set` em Java. O desafio principal consiste em criar um conjunto para armazenar as cores do arco-√≠ris e realizar diversas opera√ß√µes de manipula√ß√£o e exibi√ß√£o.

Os objetivos pr√°ticos incluem:

* **Exibi√ß√£o e Contagem:** Listar todas as cores, uma abaixo da outra, e verificar a quantidade total de elementos que o conjunto possui.
* **Ordena√ß√£o:** Exibir os dados em ordem alfab√©tica e na ordem inversa √† da que foi informada.
* **Filtragem:** Selecionar e exibir apenas as cores que come√ßam com a letra "v", al√©m de remover do conjunto todas as cores que n√£o atendem a esse crit√©rio.
* **Gerenciamento de Estado:** Limpar completamente o conjunto e conferir se a estrutura ficou vazia.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-16h28m57s544.jpg" alt="" width="840">
</p>

Esta imagem detalha um exerc√≠cio focado na ordena√ß√£o de objetos personalizados dentro de cole√ß√µes. O objetivo √© criar uma classe chamada `LinguagemFavorita` contendo os atributos `nome`, `anoDeCriacao` e `ide`.

Ap√≥s criar um conjunto com tr√™s linguagens, o programa deve ordenar essa cole√ß√£o seguindo diferentes crit√©rios:

* **Ordem de Inser√ß√£o:** Mantendo a sequ√™ncia em que os elementos foram adicionados ao conjunto.
* **Ordem Natural:** Realizando a ordena√ß√£o baseada no atributo `nome`.
* **IDE:** Ordenando os elementos pelo nome da IDE utilizada.
* **Crit√©rios Compostos:** Ordena√ß√µes combinadas por `Ano de cria√ß√£o e nome`, ou por `Nome, ano de cria√ß√£o e IDE`.

Ao final, o programa deve exibir as linguagens no console, uma abaixo da outra, para validar os resultados das ordena√ß√µes aplicadas.


## Parte 4 - Map

### üü© V√≠deo 13 - Cole√ß√µes de pares: Map

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_13.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/67376a55-e735-4b35-8b33-323cf5e0e74e?autoplay=1

Este v√≠deo aborda a interface Map em Java, suas caracter√≠sticas, implementa√ß√µes comuns (HashMap, LinkedHashMap, TreeMap) e um comparativo entre elas.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-18h23m49s082.jpg" alt="" width="840">
</p>

### Introdu√ß√£o √† Interface Map e sua Hierarquia

A interface **Map**, pertencente ao pacote `java.util`, representa uma estrutura de dados distinta das interfaces `List` e `Set`. Diferente delas, o **Map n√£o estende a interface Collection**, embora fa√ßa parte do framework de cole√ß√µes do Java. Sua principal caracter√≠stica √© o armazenamento de elementos no formato de **Pares (Chave e Valor)**.

Nesta estrutura:

* **Chaves (Key):** Devem ser √∫nicas e n√£o permitem duplicidade.
* **Valores (Value):** Podem ser repetidos e est√£o associados a uma chave espec√≠fica.

A hierarquia apresentada destaca as principais implementa√ß√µes e subinterfaces:

* **Hashtable:** Uma implementa√ß√£o antiga e *thread-safe*.
* **HashMap e LinkedHashMap:** Onde a `LinkedHashMap` estende a funcionalidade da `HashMap`.
* **TreeMap:** Uma implementa√ß√£o que garante a ordena√ß√£o, estendendo `NavigableMap` e `SortedMap`.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-18h24m07s688.jpg" alt="" width="840">
</p>

### Comparativo T√©cnico entre Implementa√ß√µes Map

Para escolher a implementa√ß√£o ideal, √© necess√°rio analisar crit√©rios de performance, ordena√ß√£o e estrutura de dados. Abaixo, os dados comparativos detalhados entre **HashMap**, **LinkedHashMap** e **TreeMap**:

| Propriedade | HashMap | LinkedHashMap | TreeMap |
| --- | --- | --- | --- |
| **Complexidade (Big O)** |  |  |  |
| **Ordem de Itera√ß√£o** | Aleat√≥ria | Ordem de Inser√ß√£o ou Acesso | Ordem Natural ou Comparator |
| **Chaves Nulas** | Permitido | Permitido | N√£o permitido (para ordem natural) |
| **Interface** | Map | Map | Map, SortedMap e NavigableMap |
| **Sincroniza√ß√£o** | Nenhuma (Manual via Collections) | Nenhuma (Manual via Collections) | Nenhuma (Manual via Collections) |
| **Estrutura de Dados** | Tabela Hash (List of Buckets) | Lista Duplamente Encadeada | √Årvore Rubro-Negra (Red-Black Tree) |

**Considera√ß√µes Importantes:**

* **Performance:** `HashMap` e `LinkedHashMap` oferecem alta performance para opera√ß√µes b√°sicas como `get`, `put` e `remove`. O `TreeMap` √© ligeiramente mais lento devido ao esfor√ßo de manter a √°rvore balanceada e ordenada.
* **Casos de Uso:** Use `TreeMap` quando precisar de busca por intervalos ou ordena√ß√£o constante. O `LinkedHashMap` √© ideal para caches (como o LRU) onde a ordem de acesso importa.
* **Requisitos de Chave:** Para as implementa√ß√µes baseadas em Hash, √© obrigat√≥rio sobrescrever os m√©todos `equals()` e `hashCode()` para garantir o funcionamento correto da cole√ß√£o. No caso do `TreeMap`, a chave deve implementar `Comparable` ou um `Comparator` deve ser fornecido.

O pr√≥ximo passo √© colocar esse conhecimento em pr√°tica atrav√©s dos principais m√©todos de manipula√ß√£o dessas cole√ß√µes.      


### üü© V√≠deo 14 - Conhecendo os m√©todos Map - parte 1

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_14.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/961c9cdc-fd2d-459f-b4dd-95892ad88552?autoplay=1

Este v√≠deo aborda a implementa√ß√£o t√©cnica e os conceitos fundamentais da interface Map no Java, utilizando um exemplo pr√°tico de consumo de combust√≠vel de diferentes modelos de carros.

### Anota√ß√µes

Nesta aula pr√°tica, exploramos a interface **Map** do Java, focando em como gerenciar cole√ß√µes de pares chave-valor. O exerc√≠cio proposto consiste em criar um dicion√°rio para relacionar modelos de carros aos seus respectivos consumos de combust√≠vel na estrada.

```java
package br.com.dio.collection.map;

import java.util.*;

public class ExemploMap {
    public static void main(String[] args) {
/*
 Dada os modelos dos carros e seus respectivos consumos na estrada, fa√ßa:
 modelo = gol - consumo = 14,4km/l
 modelo = uno - consumo = 15,6 km/l
 modelo = mobi - consumo = 16,1 km/l
 modelo = hb20 - consumo = 14,5 km/l
 modelo = kwid - consumo = 15,6 km/l
 */

//        Map carrosPopulares2020 = new HashMap(); //antes do java 5
//        Map<String, Double> carrosPopulares = new HashMap<>(); //Generics(jdk 5) - Diamont Operator(jdk 7)
//        HashMap<String, Double> carrosPopulares = new HashMap<>();
//        Map<String, Double> carrosPopulares2020 = Map.of("gol", 14.4, "uno", 15.6, "mobi", 16.1, "hb20", 14.5, "kwid", 15.6)

        System.out.println("Crie um dicion√°rio que relacione os modelos e seus respectivos consumos: ");
        Map<String, Double> carrosPopulares = new HashMap<>() {{
            put("gol", 14.4);
            put("uno", 15.6);
            put("mobi", 16.1);
            put("hb20", 14.5);
            put("kwid", 15.6);
        }};
        System.out.println(carrosPopulares.toString());

        System.out.println("Substitua o consumo do gol por 15,2 km/l: ");
        carrosPopulares.put("gol", 15.2);
        System.out.println(carrosPopulares);

        System.out.println("Confira se o modelo tucson est√° no dicion√°rio: " + carrosPopulares.containsKey("tucson"));

        System.out.println("Exiba o consumo do uno: " + carrosPopulares.get("uno"));

//        System.out.println("Exiba o terceiro modelo adicionado: ");

        System.out.println("Exiba os modelos: ");
        Set<String> modelos = carrosPopulares.keySet();
        System.out.println(modelos);

        System.out.println("Exiba os consumos dos carros: ");
        Collection<Double> consumos = carrosPopulares.values();
        System.out.println(consumos);

        System.out.println("Exiba o modelo mais econ√¥mico e seu consumo: ");

        Double consumoMaisEficiente = Collections.max(carrosPopulares.values());
        Set<Map.Entry<String, Double>> entries = carrosPopulares.entrySet();
        String modeloMaisEficiente = "";

        for (Map.Entry<String, Double> entry : entries) {
            if (entry.getValue().equals(consumoMaisEficiente)) {
                modeloMaisEficiente = entry.getKey();
                System.out.println("Modelo mais eficiente: " + modeloMaisEficiente + " - " + consumoMaisEficiente);
            }
        }

        System.out.println("Exiba o modelo menos econ√¥mico e seu consumo: " );

        Double consumoMenosEficiente = Collections.min(carrosPopulares.values());
        String modeloMenosEficiente = "";
        for (Map.Entry<String, Double> entry: carrosPopulares.entrySet()) {
            if(entry.getValue().equals(consumoMenosEficiente)) {
                modeloMenosEficiente = entry.getKey();
                System.out.println("Modelo menos eficiente: " + modeloMenosEficiente + " - " + consumoMenosEficiente);
            }
        }

        Iterator<Double> iterator = carrosPopulares.values().iterator();
        Double soma = 0d;
        while(iterator.hasNext()){
            soma += iterator.next();
        }
        System.out.println("Exiba a soma dos consumos: " + soma);

        System.out.println("Exiba a m√©dia dos consumos deste dicion√°rio de carros: " + (soma/carrosPopulares.size()));

        System.out.println(carrosPopulares);
        System.out.println("Remova os modelos com o consumo igual a 15,6 km/l: ");
        Iterator<Double> iterator1 = carrosPopulares.values().iterator();
        while(iterator1.hasNext()){
            if(iterator1.next().equals(15.6)) iterator1.remove();
        }
        System.out.println(carrosPopulares);

        System.out.println("Exiba todos os carros na ordem em que foram informados: ");
        Map<String, Double> carrosPopulares1 = new LinkedHashMap<>() {{
            put("gol", 14.4);
            put("uno", 15.6);
            put("mobi", 16.1);
            put("hb20", 14.5);
            put("kwid", 15.6);
        }};
        System.out.println(carrosPopulares1.toString());

        System.out.println("Exiba o dicion√°rio ordenado pelo modelo: ");
        Map<String, Double> carrosPopulares2 = new TreeMap<>(carrosPopulares1);
        System.out.println(carrosPopulares2.toString());

        System.out.println("Apague o dicionario de carros: ");
        carrosPopulares.clear();

        System.out.println("Confira se o dicion√°rio est√° vazio: " + carrosPopulares.isEmpty());
    }
}
```

Diferente das listas (List) ou conjuntos (Set), o Map n√£o utiliza o m√©todo `add`. Para inserir dados, utilizamos o m√©todo `put(K key, V value)`, onde definimos o tipo da chave (neste caso, `String` para o modelo) e o tipo do valor (`Double` para o consumo). Uma caracter√≠stica fundamental do Map √© que as **chaves s√£o √∫nicas**; se tentarmos inserir uma chave j√° existente, o valor ser√° sobrescrito pelo novo, funcionando como uma opera√ß√£o de substitui√ß√£o.

No exemplo visualizado, utilizamos a implementa√ß√£o `HashMap`. √â importante notar que o `HashMap` n√£o garante a ordem de inser√ß√£o dos elementos. Para conferir o conte√∫do, podemos imprimir o dicion√°rio diretamente ou verificar a exist√™ncia de chaves espec√≠ficas atrav√©s do m√©todo `containsKey()`.

Al√©m das opera√ß√µes b√°sicas, o c√≥digo demonstra como encontrar valores extremos em uma cole√ß√£o usando `Collections.max()` e `Collections.min()` sobre os valores do mapa. Para identificar qual chave pertence a um determinado valor (como descobrir o carro mais eficiente), utilizamos o `entrySet()`, que permite iterar sobre os pares de entrada e acessar m√©todos como `getKey()` e `getValue()`.     
 

### üü© V√≠deo 15- Conhecendo os m√©todos Map - parte 2

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_15.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/961c9cdc-fd2d-459f-b4dd-95892ad88552?autoplay=1

Este v√≠deo demonstra diversas opera√ß√µes e m√©todos √∫teis para manipular estruturas de dados do tipo Map em Java, focando em como extrair, processar e organizar informa√ß√µes de um dicion√°rio de carros (modelo e consumo)

### Anota√ß√µes

Nesta etapa da aula, exploramos opera√ß√µes avan√ßadas com a interface `Map` em Java, focando em como manipular cole√ß√µes de dados de forma mais granular. O exemplo utiliza um dicion√°rio de carros populares e seus respectivos consumos de combust√≠vel para demonstrar m√©todos de busca, itera√ß√£o e ordena√ß√£o. 

### Identificando Extremos e Manipulando Entradas

Para encontrar o modelo menos econ√¥mico, utilizamos a classe `Collections.min()` aplicada aos valores do Map (`carrosPopulares.values()`). No entanto, como o m√©todo `values()` retorna apenas os n√∫meros, √© necess√°rio utilizar o m√©todo `entrySet()` para obter um conjunto de entradas (`Map.Entry`) que vinculam a chave (modelo) ao valor (consumo).

Ao iterar sobre esse conjunto, comparamos o valor de cada entrada com o valor m√≠nimo encontrado. Quando h√° uma correspond√™ncia, extra√≠mos a chave associada atrav√©s do m√©todo `getKey()`.

### C√°lculos Agregados e Itera√ß√£o

Para somar os consumos e calcular a m√©dia, utilizamos um `Iterator`. O iterador percorre a `Collection` de valores, acumulando a soma em uma vari√°vel. A m√©dia √© obtida dividindo-se o total acumulado pelo tamanho do dicion√°rio (`size()`).

### Remo√ß√£o e Ordena√ß√£o

A remo√ß√£o de itens com base em um crit√©rio espec√≠fico (neste caso, consumo igual a 15,6 km/l) tamb√©m √© realizada via `Iterator`, garantindo que a estrutura do Map n√£o sofra erros de concorr√™ncia durante a exclus√£o.

Para organizar a exibi√ß√£o dos dados:

* **LinkedHashMap**: Utilizado para exibir os elementos na ordem exata em que foram inseridos.
* **TreeMap**: Utilizado para ordenar o dicion√°rio automaticamente de acordo com a ordem natural das chaves (ordem alfab√©tica dos modelos).

Por fim, o m√©todo `clear()` √© demonstrado para esvaziar o dicion√°rio, seguido de `isEmpty()` para validar que a estrutura n√£o cont√©m mais elementos.

```java
// Exemplo de manipula√ß√£o de Map com Java
Map<String, Double> carrosPopulares = new HashMap<>() {{
    put("gol", 14.4);
    put("uno", 15.6);
    put("mobi", 16.1);
    put("hb20", 14.5);
    put("kwid", 15.6);
}};

// Encontrando o modelo menos eficiente
Double consumoMenosEficiente = Collections.min(carrosPopulares.values());
String modeloMenosEficiente = "";
for (Map.Entry<String, Double> entry : carrosPopulares.entrySet()) {
    if (entry.getValue().equals(consumoMenosEficiente)) {
        modeloMenosEficiente = entry.getKey();
        System.out.println("Modelo menos eficiente: " + modeloMenosEficiente + " - " + consumoMenosEficiente);
    }
}

// Removendo modelos com consumo espec√≠fico
Iterator<Double> iterator1 = carrosPopulares.values().iterator();
while(iterator1.hasNext()){
    if(iterator1.next().equals(15.6)) iterator1.remove();
}

// Ordena√ß√£o com TreeMap
Map<String, Double> carrosPopulares2 = new TreeMap<>(carrosPopulares);
System.out.println(carrosPopulares2.toString());

```

### üü© V√≠deo 16 - Ordena√ß√£o - Map

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_16.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/9b8bf5b4-b3df-4ed8-8dd9-5f65cef933be?autoplay=1

Este v√≠deo demonstra como ordenar elementos dentro de diferentes tipos de Map em Java, explorando a ordena√ß√£o aleat√≥ria, por inser√ß√£o, alfab√©tica pela chave e alfab√©tica pelo valor, utilizando HashMap, LinkedHashMap, TreeMap e TreeSet com um Comparator personalizado.

### Anota√ß√µes

Nesta aula, o objetivo √© demonstrar como manipular e ordenar cole√ß√µes do tipo `Map` em Java, utilizando diferentes implementa√ß√µes da interface para alcan√ßar crit√©rios espec√≠ficos de organiza√ß√£o (aleat√≥ria, inser√ß√£o e alfab√©tica).

```java
package br.com.dio.collection.map;

/*Dadas as seguintes informa√ß√µes sobre meus livros favoritos e seus autores,
crie um dicion√°rio e ordene este dicion√°rio:
exibindo (Nome Autor - Nome Livro);

Autor = Hawking, Stephen  - Livro = nome: Uma Breve Hist√≥ria do Tempo. p√°ginas: 256
Autor = Duhigg, Charles - Livro = nome: O Poder do H√°bito, paginas: 408
Autor = Harari, Yuval Noah  - Livro = 21 Li√ß√µes Para o S√©culo 21, p√°ginas: 432
*/

import java.util.*;

public class ExemploOrdenacaoMap {
    public static void main(String[] args) {

        System.out.println("--\tOrdem aleat√≥ria\t--");
        Map<String, Livro> meusLivros = new HashMap<>() {{
            put(" Hawking, Stephen", new Livro("Uma Breve Hist√≥ria do Tempo", 256));
            put(" Duhigg, Charles", new Livro("O Poder do H√°bito", 408));
            put(" Harari, Yuval Noah", new Livro("21 Li√ß√µes Para o S√©culo 21", 432));
        }};
        for (Map.Entry<String, Livro> livro : meusLivros.entrySet())
            System.out.println(livro.getKey() + " - " + livro.getValue().getNome());

        System.out.println("--\tOrdem Inser√ß√£o\t--");
        Map<String, Livro> meusLivros1 = new LinkedHashMap<>() {{
            put(" Hawking, Stephen", new Livro("Uma Breve Hist√≥ria do Tempo", 256));
            put(" Duhigg, Charles", new Livro("O Poder do H√°bito", 408));
            put(" Harari, Yuval Noah", new Livro("21 Li√ß√µes Para o S√©culo 21", 432));
        }};
        for (Map.Entry<String, Livro> livro : meusLivros1.entrySet())
            System.out.println(livro.getKey() + " - " + livro.getValue().getNome());

        System.out.println("--\tOrdem alfab√©tica autores\t--");
        Map<String, Livro> meusLivros2 = new TreeMap<>(meusLivros1);
        for (Map.Entry<String, Livro> livro : meusLivros2.entrySet())
            System.out.println(livro.getKey() + " - " + livro.getValue().getNome());

        System.out.println("--\tOrdem alfab√©tica nomes dos livros\t--");

        Set<Map.Entry<String, Livro>> meusLivros3 = new TreeSet<>(new ComparatorNome());
        meusLivros3.addAll(meusLivros.entrySet());
        for (Map.Entry<String, Livro> livro : meusLivros3)
            System.out.println(livro.getKey() + " - " + livro.getValue().getNome());

//        System.out.println("--\tOrdem n√∫mero de p√°gina\t--"); //Pra voc√™

    }
}

class Livro {
    private String nome;
    private Integer paginas;

    public Livro(String nome, Integer paginas) {
        this.nome = nome;
        this.paginas = paginas;
    }

    public String getNome() {
        return nome;
    }

    public Integer getPaginas() {
        return paginas;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Livro livro = (Livro) o;
        return nome.equals(livro.nome) && paginas.equals(livro.paginas);
    }

    @Override
    public int hashCode() {
        return Objects.hash(nome, paginas);
    }

    @Override
    public String toString() {
        return "Livro{" +
                "nome='" + nome + '\'' +
                ", paginas=" + paginas +
                '}';
    }
}

class ComparatorNome implements Comparator<Map.Entry<String, Livro>>{

    @Override
    public int compare(Map.Entry<String, Livro> l1, Map.Entry<String, Livro> l2) {
        return l1.getValue().getNome().compareToIgnoreCase(l2.getValue().getNome());
    }
}
```

Para exemplificar, √© criado um dicion√°rio de livros favoritos onde a **Chave (Key)** √© o nome do autor (String) e o **Valor (Value)** √© um objeto da classe `Livro`, que cont√©m os atributos `nome` e `paginas`.

### Implementa√ß√£o da Classe Base

Para garantir o funcionamento correto das cole√ß√µes, especialmente ao utilizar `HashMap` e `TreeMap`, a classe `Livro` deve ser implementada com o construtor, m√©todos acessores (getters) e a sobrescrita dos m√©todos essenciais:

* **`equals` e `hashCode**`: Necess√°rios para que o Map consiga identificar e comparar os objetos corretamente.
* **`toString`**: Sobrescrito para que, ao imprimir os valores, o Java exiba os dados do livro em vez do endere√ßo de mem√≥ria.

### Formas de Ordena√ß√£o Apresentadas

1. **Ordem Aleat√≥ria (`HashMap`)**: Os elementos s√£o exibidos sem uma ordem garantida, variando conforme o hashing interno.
2. **Ordem de Inser√ß√£o (`LinkedHashMap`)**: Mant√©m a sequ√™ncia exata em que os autores e livros foram adicionados ao dicion√°rio.
3. **Ordem Alfab√©tica por Chave (`TreeMap`)**: Ordena automaticamente o dicion√°rio com base no nome dos autores.
4. **Ordem Alfab√©tica por Valor**: Para ordenar pelo nome do livro (que est√° no objeto `Livro`), utiliza-se um `TreeSet` recebendo um `Comparator` personalizado que acessa `getValue().getNome()`.

O desafio final proposto consiste em realizar a ordena√ß√£o pelo n√∫mero de p√°ginas, seguindo a mesma l√≥gica de cria√ß√£o de um `Comparator` espec√≠fico para o campo `paginas`.


### üü© V√≠deo 17 - Exerc√≠cios propostos - Map

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_17.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/93d1881d-5c1b-41d4-92df-fa970c91742b?autoplay=1

Este v√≠deo marca o final de uma aula, introduzindo uma s√©rie de exerc√≠cios pr√°ticos e um desafio adicional, focados principalmente na manipula√ß√£o de dicion√°rios em Python e na simula√ß√£o de eventos aleat√≥rios.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-19h35m51s571.jpg" alt="" width="840">
</p>

Nesta etapa da aula, iniciamos os exerc√≠cios propostos focados na manipula√ß√£o de cole√ß√µes. O objetivo √© praticar a estrutura de dicion√°rios utilizando dados demogr√°ficos reais de estados do Nordeste brasileiro.

As tarefas iniciais consistem em:

1. **Cria√ß√£o do dicion√°rio**: Relacionar os estados (chaves) √†s suas respectivas popula√ß√µes (valores).
2. **Atualiza√ß√£o de dados**: Corrigir a popula√ß√£o do Rio Grande do Norte (RN).
3. **Verifica√ß√£o e inser√ß√£o**: Checar a exist√™ncia do estado da Para√≠ba (PB) no dicion√°rio e adicion√°-lo caso n√£o esteja presente.

**Dados para o exerc√≠cio:**

* PE: 9.616.621 
* AL: 3.351.543 
* CE: 9.187.103 
* RN: 3.534.265 

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-19h36m01s158.jpg" alt="" width="840">
</p>

Dando continuidade aos exerc√≠cios de fixa√ß√£o, s√£o propostas opera√ß√µes avan√ßadas de visualiza√ß√£o, c√°lculo e filtragem sobre o dicion√°rio de estados criado anteriormente:

* **Ordena√ß√£o**: Exibir os dados na ordem de inser√ß√£o e tamb√©m em ordem alfab√©tica. 
* **An√°lise de Extremos**: Identificar e exibir os estados com a menor e a maior popula√ß√£o. 
* **Opera√ß√µes Matem√°ticas**: Calcular a soma total e a m√©dia da popula√ß√£o de todos os estados listados. 
* **Limpeza de Dados**: Remover entradas com popula√ß√£o inferior a 4.000.000 e, por fim, esvaziar o dicion√°rio completamente para validar se ele ficou vazio. 

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-19h36m04s962.jpg" alt="" width="840">
</p>

Al√©m dos exerc√≠cios estruturados, √© apresentado um desafio de l√≥gica de programa√ß√£o para simular o lan√ßamento de dados. O objetivo √© trabalhar com gera√ß√£o de n√∫meros aleat√≥rios e contagem de frequ√™ncia:

* **Simula√ß√£o**: Lan√ßar um dado de 6 faces 100 vezes. 
* **Armazenamento**: Guardar todos os resultados obtidos. 
* **An√°lise**: Contabilizar e mostrar quantas vezes cada face (valor) do dado apareceu durante as 100 itera√ß√µes. 

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-26-19h36m10s517.jpg" alt="" width="840">
</p>

Para aprofundar o conhecimento em ordena√ß√£o de cole√ß√µes complexas, s√£o sugeridos cen√°rios onde a chave ou o valor n√£o s√£o tipos primitivos simples (como String ou Integer), mas sim objetos:

1. **Chave (Objeto) + valor (Set de Objetos)**: √ötil para estruturas de dados onde uma entidade principal mapeia para um conjunto de sub-entidades. 
2. **Chave (Objeto) + valor (Objeto)**: Quando a rela√ß√£o de mapeamento ocorre diretamente entre dois objetos complexos. 

Estes exemplos visam preparar o desenvolvedor para situa√ß√µes reais de mercado onde a estrutura de dados exige maior complexidade t√©cnica do que o uso de tipos b√°sicos.


## Parte 5 - Stream

### üü© V√≠deo 18 - Vis√£o geral: Stream API - parte 1

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_18.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/b592a952-7c4d-4650-abaa-74b93573b441?autoplay=1

Esta aula aborda a transi√ß√£o conceitual e pr√°tica entre interfaces funcionais, classes an√¥nimas e express√µes Lambda no contexto da Stream API em Java. O conte√∫do define uma interface funcional como aquela que possui um √∫nico m√©todo abstrato (SAM - Single Abstract Method), exemplificando-a com as interfaces Function, Comparator e Action Listener. A aula demonstra como simplificar a implementa√ß√£o de classes an√¥nimas verbosas atrav√©s da sintaxe Lambda, caracterizando-a como uma fun√ß√£o sem declara√ß√£o composta por argumento, flecha e corpo. Por fim, destaca-se que o uso de Lambdas visa a legibilidade e a simplifica√ß√£o do c√≥digo ao reduzir a estrutura necess√°ria para implementar comportamentos, como a compara√ß√£o de objetos em uma lista por atributos espec√≠ficos.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-27-14h12m50s185.jpg" alt="" width="840">
</p>

Esta √© a introdu√ß√£o da **Aula 4** do curso de Java, voltada especificamente para o ecossistema de **Collections** e a introdu√ß√£o ao **Java Streams**. O objetivo desta se√ß√£o √© apresentar as ferramentas modernas de manipula√ß√£o de dados que preparam o desenvolvedor para o uso da Stream API.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-27-14h12m53s034.jpg" alt="" width="840">
</p>

Nesta aula, ser√£o abordados cinco t√≥picos fundamentais para o dom√≠nio da programa√ß√£o funcional e processamento de dados em Java:

1. **Classe An√¥nima**: Implementa√ß√µes r√°pidas de classes sem nome.
2. **Functional Interface**: A base te√≥rica (SAM) que permite o uso de lambdas.
3. **Lambda**: A sintaxe enxuta para expressar fun√ß√µes.
4. **Reference Method**: Uma forma ainda mais simplificada de referenciar m√©todos existentes.
5. **Stream API**: O ponto culminante, onde todos os conceitos anteriores s√£o aplicados para manipular cole√ß√µes de forma declarativa.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-27-14h13m00s041.jpg" alt="" width="840">
</p>

A **Classe An√¥nima** √© um recurso que permite declarar e instanciar uma classe simultaneamente em uma √∫nica instru√ß√£o. Ela √© ideal para situa√ß√µes onde voc√™ precisa criar uma implementa√ß√£o espec√≠fica que ser√° utilizada apenas uma vez no c√≥digo, como em comparadores.

No exemplo apresentado, observa-se a transi√ß√£o de um comparador tradicional para uma classe an√¥nima:

```java
// Implementa√ß√£o tradicional (Exige cria√ß√£o de classe externa)
class ComparatorIdade implements Comparator<Gato> {
    @Override
    public int compare(Gato g1, Gato g2) {
        return Integer.compare(g1.getIdade(), g2.getIdade());
    }
}
meusGatos.sort(new ComparatorIdade());

// Implementa√ß√£o com Classe An√¥nima (Instanciada no local de uso)
meusGatos.sort(new Comparator<Gato>() {
    @Override
    public int compare(Gato g1, Gato g2) {
        return Integer.compare(g1.getIdade(), g2.getIdade());
    }
});

```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-27-14h13m12s958.jpg" alt="" width="840">
</p>

Uma **Functional Interface** (Interface Funcional) √© caracterizada por possuir exatamente um **SAM (Single Abstract Method)**, ou seja, apenas um m√©todo abstrato. Esta regra √© o que permite ao Java converter express√µes Lambda no tipo da interface correspondente.

Embora o uso da anota√ß√£o `@FunctionalInterface` seja uma boa pr√°tica para evitar a adi√ß√£o acidental de novos m√©todos, qualquer interface que siga a regra do m√©todo √∫nico (como o exemplo do `ActionListener`) √© considerada funcional.

```java
// Interface Funcional com anota√ß√£o expl√≠cita
@FunctionalInterface
public interface Comparator<T> {
    int compare(T var1, T var2);
}

// Interface Funcional sem anota√ß√£o (Baseada no SAM)
public interface ActionListener extends EventListener {
    void actionPerformed(ActionEvent var1);
}

```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-27-14h13m14s888.jpg" alt="" width="840">
</p>

A **Express√£o Lambda** √© definida como uma fun√ß√£o sem declara√ß√£o formal. Isso significa que n√£o √© necess√°rio explicitar um nome para a fun√ß√£o, o tipo de retorno ou modificadores de acesso. A sintaxe b√°sica √© composta por:
`(argumento) -> (corpo)`

A ideia central √© que o comportamento seja declarado exatamente no ponto onde ser√° executado, aumentando a clareza do c√≥digo.

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-27-14h13m21s979.jpg" alt="" width="840">
</p>

Neste ponto, √© demonstrado como o **Lambda** simplifica drasticamente a escrita em compara√ß√£o com as **Classes An√¥nimas**. No exemplo de ordena√ß√£o de uma lista de gatos pelo nome, a estrutura burocr√°tica da classe an√¥nima √© substitu√≠da por uma √∫nica linha:

```java
// Utilizando Classe An√¥nima (Verboso)
meusGatos.sort(Comparator.comparing(new Function<Gato, String>() {
    @Override
    public String apply(Gato gato) {
        return gato.getNome();
    }
}));

// Utilizando Lambda (Simplificado)
meusGatos.sort(Comparator.comparing((Gato gato) -> gato.getNome()));

```

A express√£o lambda cumpre a mesma fun√ß√£o da interface `Function`, recebendo um objeto do tipo `Gato` e retornando seu nome para o comparador, por√©m de forma muito mais leg√≠vel.      


### üü© V√≠deo 19 - Vis√£o geral: Stream API - parte 2

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_19.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/1af2e285-8b76-4ff2-b763-dd79b99e08ec?autoplay=1

Esta aula aborda a simplifica√ß√£o do c√≥digo Java moderno atrav√©s do uso de Method References e da Stream API, recursos introduzidos no Java 8 para promover a programa√ß√£o funcional. O Method Reference, identificado pelo operador ::, √© apresentado como uma sintaxe ainda mais concisa que as express√µes lambda para referenciar m√©todos ou construtores de forma direta. O conte√∫do detalha como essas ferramentas se conectam: as Streams facilitam a manipula√ß√£o de cole√ß√µes por meio de uma estrutura composta por fonte (Source), opera√ß√µes intermedi√°rias (Pipeline) e opera√ß√µes terminais, frequentemente utilizando interfaces funcionais (padr√£o SAM) e lambdas em seus argumentos. Em suma, o v√≠deo demonstra que a ado√ß√£o dessas pr√°ticas resulta em um c√≥digo mais leg√≠vel, de f√°cil manuten√ß√£o e preparado para paraleliza√ß√£o, reduzindo a complexidade de implementa√ß√µes que anteriormente exigiriam classes an√¥nimas extensas.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-27-14h36m27s175.jpg" alt="" width="840">
</p>

O **Method Reference** (ou Reference Method) √© um recurso introduzido no Java 8 que funciona como uma forma de simplificar express√µes lambda. Ele permite referenciar um m√©todo ou construtor de uma classe de forma funcional, indicando que ele deve ser utilizado em um ponto espec√≠fico do c√≥digo para torn√°-lo mais leg√≠vel. A sintaxe utiliza o s√≠mbolo `::` entre a classe (ou refer√™ncia) e o nome do m√©todo, sem os par√™nteses. 

No exemplo pr√°tico de ordena√ß√£o de uma lista de objetos, podemos comparar a abordagem tradicional com a simplifica√ß√£o oferecida por este recurso:

**Sem Reference Method (Utilizando Lambda):**
Neste caso, a interface funcional `Function` √© implementada atrav√©s de um lambda, onde definimos explicitamente o argumento (`gato`) e a l√≥gica no corpo (`gato.getNome()`). 

```java
List<Gato> meusGatos = new ArrayList<>(){{
    add(new Gato("Jon", 12, "preto"));
    add(new Gato("Simba", 6, "tigrado"));
    add(new Gato("Jon", 18, "amarelo"));
}};

meusGatos.sort(Comparator.comparing((Gato gato) -> gato.getNome()));

```

**Com Reference Method:**
A sintaxe √© reduzida drasticamente. Como o Java consegue inferir o tipo de dado da lista, substitu√≠mos a express√£o lambda pelo nome da classe seguido de `::` e o m√©todo de acesso. 

```java
List<Gato> meusGatos = new ArrayList<>(){{
    add(new Gato("Jon", 12, "preto"));
    add(new Gato("Simba", 6, "tigrado"));
    add(new Gato("Jon", 18, "amarelo"));
}};

meusGatos.sort(Comparator.comparing(Gato::getNome));

```

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-27-14h36m33s451.jpg" alt="" width="840">
</p>

A **Streams API** traz uma nova op√ß√£o para a manipula√ß√£o de cole√ß√µes em Java seguindo os princ√≠pios da programa√ß√£o funcional. Quando combinada com express√µes lambda, ela oferece uma maneira simples e concisa de lidar com conjuntos de elementos, facilitando a manuten√ß√£o do c√≥digo e permitindo a paraleliza√ß√£o sem efeitos colaterais indesejados. 

A estrutura fundamental de uma Stream √© composta por tr√™s partes principais: 

* **Source (Fonte):** √â a origem dos dados, geralmente uma `Collection` (como uma lista ou conjunto). 
* **Pipeline (Opera√ß√µes Intermedi√°rias):** Sequ√™ncia de opera√ß√µes que transformam ou filtram os dados da fonte. 
* **Terminal (Opera√ß√£o Terminal):** A opera√ß√£o final que encerra a Stream e produz um resultado ou um efeito colateral (como uma nova lista, um valor √∫nico ou uma impress√£o em tela). 

Essa arquitetura permite que o desenvolvedor foque no "o que" deve ser feito com os dados, em vez de "como" iterar manualmente sobre eles.



### üü© V√≠deo 20 - Principais opera√ß√µes Stream API - parte 1

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_20.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/cca159e8-b88c-42c5-9d95-0cd615a5d6bf?autoplay=1

Esta aula aborda a refatora√ß√£o de c√≥digo Java voltada para a ordena√ß√£o de cole√ß√µes do tipo Map, evoluindo de implementa√ß√µes tradicionais para sintaxes modernas da linguagem. A instru√ß√£o demonstra a transi√ß√£o do uso de classes Comparator externas para o emprego de classes an√¥nimas e, posteriormente, a simplifica√ß√£o atrav√©s do m√©todo est√°tico `Comparator.comparing` associado √† interface funcional `Function`. O √°pice do conte√∫do foca na implementa√ß√£o de express√µes Lambda, detalhando o processo pr√°tico de redu√ß√£o da verbosidade do c√≥digo para alcan√ßar uma escrita mais fluida e eficiente. Al√©m de apresentar a l√≥gica de ordena√ß√£o por atributos espec√≠ficos de um objeto, a aula incentiva o dom√≠nio das ferramentas da IDE para auxiliar na constru√ß√£o dessa sintaxe e prop√µe exerc√≠cios pr√°ticos de fixa√ß√£o antes de introduzir conceitos de Stream API e Method Reference.

### Anota√ß√µes

Nesta aula, o foco √© a refatora√ß√£o de um c√≥digo Java voltado para a ordena√ß√£o de dicion√°rios (`Map`). O cen√°rio base utiliza uma agenda de contatos onde cada entrada possui um ID (chave) e um objeto `Contato` (valor), contendo os atributos `nome` e `numero`.

```java
package br.com.dio.collection.streamAPI;

import br.com.dio.collection.map.exercicioProposto03.Contato;

import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;

/*Dadas as seguintes informa√ß√µes  de id e contato, crie um dicion√°rio e
ordene este dicion√°rio exibindo (Nome id - Nome contato);

id = 1 - Contato = nome: Simba, numero: 2222;
id = 4 - Contato = nome: Cami, numero: 5555;
id = 3 - Contato = nome: Jon, numero: 1111;
*/
public class RefatoracaoOrdenacaoMap {

    public static void main(String[] args) {
        System.out.println("--\tOrdem aleat√≥ria\t--");
        Map<Integer, Contato> agenda = new HashMap<>() {{
           put(1, new Contato("Simba", 5555));
           put(4, new Contato("Cami", 1111));
           put(3, new Contato("Jon", 2222));
        }};
        System.out.println(agenda);
        for (Map.Entry<Integer, Contato> entry: agenda.entrySet()) {
            System.out.println(entry.getKey() + " - " + entry.getValue().getNome());
        }

        System.out.println("--\tOrdem Inser√ß√£o\t--");
        Map<Integer, Contato> agenda1 = new LinkedHashMap<>() {{
            put(1, new Contato("Simba", 5555));
            put(4, new Contato("Cami", 1111));
            put(3, new Contato("Jon", 2222));
        }};
        System.out.println(agenda1);
        for (Map.Entry<Integer, Contato> entry: agenda1.entrySet()) {
            System.out.println(entry.getKey() + " - " + entry.getValue().getNome());
        }

        System.out.println("--\tOrdem id\t--");
        Map<Integer, Contato> agenda2 = new TreeMap<>(agenda);
        System.out.println(agenda2);
        for (Map.Entry<Integer, Contato> entry: agenda2.entrySet()) {
            System.out.println(entry.getKey() + " - " + entry.getValue().getNome());
        }

        System.out.println("--\tOrdem n√∫mero telefone\t--");
        //precisamos organizar os valores. Logo:
        /*Set<Map.Entry<Integer, Contato>> set = new TreeSet<>(new Comparator<Map.Entry<Integer, Contato>>() {
            @Override
            public int compare(Map.Entry<Integer, Contato> cont1, Map.Entry<Integer, Contato> cont2) {
                return Integer.compare(cont1.getValue().getNumero(), cont2.getValue().getNumero());
            }
        });*/

        /*Set<Map.Entry<Integer, Contato>> set = new TreeSet<>(Comparator.comparing(
                new Function<Map.Entry<Integer, Contato>, Integer>() {
                    @Override
                    public Integer apply(Map.Entry<Integer, Contato> cont) {
                        return cont.getValue().getNumero();
                    }
                }));*/

        Set<Map.Entry<Integer, Contato>> set = new TreeSet<>(Comparator.comparing(
                cont -> cont.getValue().getNumero()));
        set.addAll(agenda.entrySet());
        for (Map.Entry<Integer, Contato> entry: set) {
            System.out.println(entry.getKey() + " - " + entry.getValue().getNumero() +
                    ": " +entry.getValue().getNome());
        }

        System.out.println("--\tOrdem nome contato\t--");
        //precisamos organizar os valores. Logo:
        Set<Map.Entry<Integer, Contato>> set1 = new TreeSet<>(Comparator.comparing(
                cont -> cont.getValue().getNome()));
        set1.addAll(agenda.entrySet());
        //imprimindo usando forEach
        set1.forEach(entry -> System.out.println(entry.getKey() + " - " + entry.getValue().getNome()));
    }
}

/*class ComparatorOrdemNumerica implements Comparator<Map.Entry<Integer, Contato>> {
    @Override
    public int compare(Map.Entry<Integer, Contato> cont1, Map.Entry<Integer, Contato> cont2) {
        return Integer.compare(cont1.getValue().getNumero(), cont2.getValue().getNumero());
    }
}*/

/*class ComparatorOrdemNomeContato implements Comparator<Map.Entry<Integer, Contato>> {
    @Override
    public int compare(Map.Entry<Integer, Contato> cont1, Map.Entry<Integer, Contato> cont2) {
        return cont1.getValue().getNome().compareToIgnoreCase(cont2.getValue().getNome());
    }
}*/
```

A estrutura inicial demonstra diferentes formas de organiza√ß√£o:

* **Ordem Aleat√≥ria**: Implementada atrav√©s de um `HashMap`. 
* **Ordem de Inser√ß√£o**: Utilizando um `LinkedHashMap`. 
* **Ordem de ID (Chave)**: Realizada automaticamente pelo `TreeMap`. 

O ponto central da aula √© a evolu√ß√£o da ordena√ß√£o por **n√∫mero de telefone** (um atributo do valor do Map). A professora demonstra o processo de simplifica√ß√£o do c√≥digo, partindo de implementa√ß√µes verbosas para abordagens mais modernas e concisas: 

1.**Classe An√¥nima com Comparator**: Em vez de criar uma classe externa, utiliza-se `new Comparator<Map.Entry<Integer, Contato>>()` diretamente na inst√¢ncia do `TreeSet`, sobrescrevendo o m√©todo `compare`. 
2. **Interface Funcional Function**: Evolui para o uso do m√©todo est√°tico `Comparator.comparing`, que recebe uma `Function` para extrair a chave de compara√ß√£o (neste caso, o n√∫mero do contato). 
3. **Express√µes Lambda**: A simplifica√ß√£o m√°xima ocorre com a remo√ß√£o de toda a sintaxe de classes an√¥nimas, reduzindo a l√≥gica a uma instru√ß√£o direta: `cont -> cont.getValue().getNumero()`. 

```java
// Exemplo de refatora√ß√£o para ordena√ß√£o por n√∫mero de telefone usando Lambda
Set<Map.Entry<Integer, Contato>> set = new TreeSet<>(Comparator.comparing(
    cont -> cont.getValue().getNumero()));
set.addAll(agenda.entrySet());

// Exemplo de ordena√ß√£o por nome do contato
Set<Map.Entry<Integer, Contato>> set1 = new TreeSet<>(Comparator.comparing(
    cont -> cont.getValue().getNome()));
set1.addAll(agenda.entrySet());

```

A aula conclui incentivando a pr√°tica da refatora√ß√£o para que o desenvolvedor se sinta confort√°vel em identificar onde remover redund√¢ncias e como utilizar as ferramentas da IDE para auxiliar na cria√ß√£o de express√µes Lambda e m√©todos de compara√ß√£o.     


### üü© V√≠deo 21 - Principais opera√ß√µes Stream API - parte 2

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_21.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/97eabea3-277e-454d-9eaf-5380a05e5f62?autoplay=1

Esta aula t√©cnica detalha o funcionamento da Stream API no Java, distinguindo opera√ß√µes intermedi√°rias, que permitem encadeamento e retornam novas streams, de opera√ß√µes terminais, que encerram o fluxo retornando valores ou objetos espec√≠ficos. Atrav√©s de exemplos pr√°ticos com uma lista de strings num√©ricas, a aula demonstra a aplica√ß√£o de m√©todos essenciais como forEach para itera√ß√£o simplificada via method reference, limit para sele√ß√£o de subconjuntos de dados, e collect para convers√£o de resultados em estruturas como Set. O conte√∫do enfatiza ainda a import√¢ncia da opera√ß√£o map para a transforma√ß√£o de tipos de dados ‚Äî exemplificando a convers√£o de strings para inteiros via interfaces funcionais ‚Äî e fornece recursos complementares para o aprofundamento nos detalhes sint√°ticos e funcionais de cada opera√ß√£o.

### Anota√ß√µes

Esta explica√ß√£o detalha o uso da **Stream API** em Java para manipular cole√ß√µes de forma funcional, baseando-se no c√≥digo e na aula fornecidos.

#### 1. Vis√£o Geral das Opera√ß√µes de Stream

As streams em Java s√£o compostas por dois tipos principais de opera√ß√µes:

* **Opera√ß√µes Intermedi√°rias:** Retornam uma nova stream, permitindo o encadeamento de v√°rias opera√ß√µes (ex: `filter`, `map`, `limit`).
* **Opera√ß√µes Terminais:** Encerram o fluxo e retornam um objeto ou um valor (ex: `forEach`, `collect`, `count`).

#### 2. Exemplos Pr√°ticos de Manipula√ß√£o

##### Impress√£o de Elementos

Para imprimir elementos, utiliza-se a opera√ß√£o terminal `forEach`. O c√≥digo evolui de um `Consumer` an√¥nimo para o uso de **Method Reference**:

```java
// Forma simplificada com Method Reference
numerosAleatorios.forEach(System.out::println); [cite: 54]

```

##### Filtragem e Coleta (Limit e Set)

O c√≥digo demonstra como extrair os 5 primeiros elementos e armazen√°-los em um `Set`. Note que o `Set` remove duplicatas automaticamente.

* **`.limit(5)`**: Pega os primeiros 5 elementos.
* **`.collect(Collectors.toSet())`**: Converte o resultado para um conjunto.

##### Transforma√ß√£o de Tipos (Map)

A opera√ß√£o `map` √© essencial para transformar o tipo dos dados dentro da stream, como converter uma `List<String>` para `List<Integer>`.

* **`.map(Integer::parseInt)`**: Transforma cada String em um n√∫mero inteiro.

##### Filtros Condicionais

Para selecionar elementos espec√≠ficos, utiliza-se o `filter` com um predicado (Lambda):

```java
// Exemplo: N√∫meros pares e maiores que 2
numerosAleatorios.stream()
    .map(Integer::parseInt)
    .filter(i -> i % 2 == 0 && i > 2) [cite: 73, 75, 76, 78]
    .collect(Collectors.toList()); [cite: 77]

```

#### 3. Opera√ß√µes Num√©ricas e Agrupamento

O c√≥digo tamb√©m aborda c√°lculos estat√≠sticos e organiza√ß√£o de dados:

* **M√©dia:** Utiliza `mapToInt` seguido de `average()`.
* **Soma de Pares:** Filtra os pares e utiliza `.sum()`.
* **Agrupamento:** O m√©todo `Collectors.groupingBy` √© usado para categorizar elementos, como m√∫ltiplos de 3 e 5.


| Opera√ß√£o | Tipo | Descri√ß√£o |
| --- | --- | --- |
| `distinct()` | Intermedi√°ria | Remove elementos duplicados da stream.|
| `sorted()` | Intermedi√°ria | Ordena a lista (ex: ordem natural).|
| `count()` | Terminal | Retorna a quantidade de elementos.|
| `min()` / `max()` | Terminal | Encontra o menor ou maior valor. |


### üü© V√≠deo 22 - Principais opera√ß√µes Stream API - parte 3

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_22.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/7beb8c44-242b-460e-9edd-d6a2faaf4a20?autoplay=1

Esta aula aborda a aplica√ß√£o pr√°tica da Stream API e do Optional no Java 8 para a manipula√ß√£o eficiente de cole√ß√µes, focando em opera√ß√µes de filtragem, transforma√ß√£o e agrega√ß√£o. A instrutora demonstra como converter listas de strings em inteiros utilizando `map` e `method reference`, filtrar elementos com base em m√∫ltiplos crit√©rios atrav√©s do m√©todo `filter` e coletar resultados em novas listas. O conte√∫do tamb√©m explora o uso de `mapToInt` e `average` para c√°lculos estat√≠sticos, introduzindo o `Optional` como mecanismo de seguran√ßa para retornos nulos, e diferencia opera√ß√µes de Stream (que n√£o alteram a fonte) de m√©todos de lista como `removeIf`, que modificam a cole√ß√£o original. Ao final, ressalta-se a expressividade e o poder do encadeamento de opera√ß√µes para simplificar c√≥digos complexos, incentivando a pr√°tica aut√¥noma em exerc√≠cios complementares de ordena√ß√£o e agrupamento.

### Anota√ß√µes

Nesta etapa da aula, o foco √© a manipula√ß√£o de cole√ß√µes utilizando a **Stream API** do Java para realizar filtragens e transforma√ß√µes de dados de forma encadeada. A instrutora demonstra como selecionar elementos espec√≠ficos de uma lista com base em m√∫ltiplas condi√ß√µes l√≥gicas.

Para o exerc√≠cio proposto ‚Äî selecionar n√∫meros pares e maiores que dois ‚Äî √© necess√°rio realizar as seguintes etapas:

1. **Transforma√ß√£o (Map):** Como a lista original `numerosAleatorios` cont√©m strings, utiliza-se o m√©todo `.map(Integer::parseInt)` para converter cada elemento em um n√∫mero inteiro.
2. **Filtragem (Filter):** Aplica-se a opera√ß√£o `filter` que recebe um `Predicate`. No exemplo did√°tico, a instrutora utiliza uma implementa√ß√£o an√¥nima (ou posteriormente simplificada para Lambda) que verifica se o n√∫mero √© par (`i % 2 == 0`) e se √© maior que dois (`i > 2`).
3. **Coleta (Collect):** Os elementos que satisfazem os crit√©rios do filtro s√£o agrupados em uma nova lista atrav√©s do `collect(Collectors.toList())`.

O uso de Streams permite que essas opera√ß√µes sejam escritas de forma declarativa, reduzindo a verbosidade em compara√ß√£o aos m√©todos tradicionais de itera√ß√£o.

```java
// Trecho correspondente √† filtragem de n√∫meros pares maiores que 2
List<Integer> listParesMaioresQue2 = numerosAleatorios.stream()
        .map(Integer::parseInt)
        .filter(i -> (i % 2 == 0 && i > 2))
        .collect(Collectors.toList());

System.out.println(listParesMaioresQue2);

```

Al√©m disso, a aula introduz o c√°lculo de m√©dias utilizando `mapToInt`, que transforma a Stream em uma `IntStream`. Isso possibilita o acesso ao m√©todo `average()`, que retorna um `OptionalDouble`. Para lidar com esse resultado de forma segura, utiliza-se o m√©todo `ifPresent`, garantindo que a impress√£o no console s√≥ ocorra se um valor v√°lido tiver sido calculado.

```java
// C√°lculo da m√©dia dos n√∫meros
numerosAleatorios.stream()
        .mapToInt(Integer::parseInt)
        .average()
        .ifPresent(System.out::println);

```

### üü© V√≠deo 23 - Conclus√£o do curso

<video width="60%" controls>
  <source src="000-Midia_e_Anexos/bootcamp_tqi_fullstack-modulo.06-curso.06-video_23.webm" type="video/webm">
    Seu navegador n√£o suporta v√≠deo HTML5.
</video>

link do v√≠deo: https://web.dio.me/track/tqi-fullstack-developer/course/trabalhando-com-collections-java/learning/428a796a-2957-4091-8729-487e512c4f1a?autoplay=1

Nesta aula de encerramento, o instrutor celebra a conclus√£o do curso introdut√≥rio de Java Collections e recomenda tr√™s trilhas de aprendizado gratuitas na plataforma DIO para aprofundamento t√©cnico. As sugest√µes incluem o curso de "Implementando Collections e Streams com Java", focado em m√©todos avan√ßados como Optional e interfaces de Queue; a forma√ß√£o em "Desenvolvimento Avan√ßado em Java", que detalha o uso de interfaces funcionais e o paradigma de programa√ß√£o funcional; e o curso de "Estrutura de Dados", que aborda conceitos fundamentais como √°rvores e listas de forma did√°tica. O v√≠deo finaliza incentivando o compartilhamento de certificados no LinkedIn, a participa√ß√£o na comunidade do Discord e a consulta ao c√≥digo-fonte dispon√≠vel no GitHub para consolidar o dom√≠nio sobre Streams, Lambdas e cole√ß√µes.

### Anota√ß√µes

<p align="center">
<img src="000-Midia_e_Anexos/vlcsnap-2026-01-27-16h26m14s053.jpg" alt="" width="840">
</p>

Nesta etapa de encerramento do curso introdut√≥rio de Collections, s√£o apresentadas recomenda√ß√µes de estudos avan√ßados dispon√≠veis na plataforma DIO para aprofundar o dom√≠nio da linguagem Java e fundamentos de computa√ß√£o. As sugest√µes focam em tr√™s pilares essenciais:

#### 1. Implementando Collections e Streams com Java

Ministrado pelo instrutor Wesley Fuchter, este curso √© o pr√≥ximo passo ideal para dominar recursos que n√£o foram explorados a fundo no m√≥dulo introdut√≥rio, tais como:

* **Interface Queue:** Compreens√£o de filas e suas implementa√ß√µes.
* **Optional:** Manipula√ß√£o segura de valores que podem ser nulos, evitando o `NullPointerException`.
* **M√©todos Avan√ßados:** Explora√ß√£o detalhada de m√©todos espec√≠ficos das estruturas `TreeSet` e `TreeMap`.

#### 2. Desenvolvimento Avan√ßado em Java

Com o instrutor Jo√£o Paulo, este conte√∫do foca na moderniza√ß√£o da linguagem e no paradigma funcional. Os t√≥picos principais incluem:

* **Interfaces Funcionais:** Entendimento profundo de como o Java utiliza fun√ß√µes como cidad√£os de primeira classe.
* **Streams e Lambdas:** Detalhamento do porqu√™ dessas implementa√ß√µes e como elas otimizam a manipula√ß√£o de dados em cole√ß√µes.
* **Orienta√ß√£o a Objetos vs. Funcional:** Uma an√°lise t√©cnica sobre a coexist√™ncia desses paradigmas no ecossistema Java atual.

#### 3. Estrutura de Dados e Algoritmos

O curso do instrutor Bruno de Campos √© fundamental para entender a "m√°gica" por tr√°s das Collections. Diferente dos anteriores, este curso foca na l√≥gica pura e em conceitos te√≥ricos aplicados, utilizando ferramentas como o **VisualG** para ilustrar:

* **Listas:** Diferen√ßas entre listas simples e listas duplamente ligadas.
* **Pilhas e Filas:** O funcionamento l√≥gico de inser√ß√£o e remo√ß√£o de dados.
* **√Årvores:** Conceitos de estruturas hier√°rquicas de dados.

O dom√≠nio desses t√≥picos, somado ao conte√∫do de introdu√ß√£o a Collections, prepara o desenvolvedor para resolver problemas complexos de engenharia de software e otimiza√ß√£o de performance.

# Certificado: Trabalhando com Collections Java

- Link na plataforma: https://hermes.dio.me/certificates/ZQ1FHJ76.pdf
- Certificado em pdf: [Certificado-Trabalhando_com_Collections_Java.pdf](000-Midia_e_Anexos/Certificado-Trabalhando_com_Collections_Java.pdf)